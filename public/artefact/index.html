<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise Policy Literacy - Network Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        :root {
            --bg-color: #050505;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent-color: #4ECDC4;
            --glass-bg: rgba(20, 20, 20, 0.6);
            --glass-border: rgba(255, 255, 255, 0.08);
            --panel-radius: 16px;

            /* L-Shape Theme */
            --l-sidebar-bg: rgba(10, 10, 10, 0.95);
            --l-header-bg: rgba(5, 5, 5, 0.85);
            --l-border: rgba(255, 255, 255, 0.08);
            --tab-text: #888;
            --tab-text-active: #fff;
            --tab-underline: #fff;
            --breadcrumb-text: #555;

            /* Inputs */
            --input-bg: rgba(255, 255, 255, 0.05);
            --input-border: rgba(255, 255, 255, 0.1);

            /* Chart 3 Panel Theme */
            --chart-panel-bg: rgba(255, 255, 255, 0.05);
            --chart-panel-border: rgba(255, 255, 255, 0.12);
            --chart-row-border: rgba(255, 255, 255, 0.12);
            --chart-row-hover: rgba(255, 255, 255, 0.1);
        }

        /* Light Theme Overrides (Polished High Contrast) */
        body.theme-light {
            --bg-color: #f0f2f5;
            /* Off-white page background */
            --text-primary: #111111;
            --text-secondary: #444444;
            /* Darker grey for readability */
            --glass-bg: rgba(255, 255, 255, 0.95);
            --glass-border: rgba(0, 0, 0, 0.08);

            /* L-Shape Light */
            --l-sidebar-bg: #ffffff;
            /* Pure white panel */
            --l-header-bg: rgba(255, 255, 255, 0.95);
            /* Semi-transparent white */
            --l-border: rgba(0, 0, 0, 0.08);
            /* Subtle separator */
            --tab-text: #555555;
            --tab-text-active: #000000;
            --tab-underline: #111111;
            --breadcrumb-text: #555555;

            /* Inputs Light */
            --input-bg: #f7f9fa;
            --input-border: #e1e4e8;

            /* Chart 3 Panel Theme Light */
            --chart-panel-bg: rgba(0, 0, 0, 0.04);
            --chart-panel-border: rgba(0, 0, 0, 0.12);
            --chart-row-border: rgba(0, 0, 0, 0.12);
            --chart-row-hover: rgba(0, 0, 0, 0.06);
        }

        body.theme-light #container {
            background: #f0f2f5;
            /* Flat off-white to improve rendering contrast */
        }

        body.theme-light .btn {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.1);
        }

        body.theme-light .btn:hover {
            background: rgba(0, 0, 0, 0.1);
            border-color: var(--text-primary);
        }

        body.theme-light .journal-item {
            color: #666;
        }

        body.theme-light .journal-item:hover {
            background: rgba(0, 0, 0, 0.05);
            color: #000;
        }

        body.theme-light .stats {
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        body.theme-light #journalList {
            background: rgba(0, 0, 0, 0.03) !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
        }

        body.theme-light .range-track {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 20px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.2);
            transition: .4s;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #333;
            /* Dark background for 'Dark Mode' state */
            border-color: rgba(255, 255, 255, 0.2);
        }

        input:checked+.slider:before {
            background-color: var(--accent-color);
        }

        /* Logic: Checked = Dark Mode (Default), Unchecked = Light Mode */
        /* Checked (Right) = Dark Mode. Unchecked (Left) = Light Mode. */

        body.theme-light .slider {
            background-color: #e0e0e0;
            border-color: rgba(0, 0, 0, 0.15);
        }

        body.theme-light .slider:before {
            background-color: #fff;
            transform: translateX(0px);
        }

        /* Dark Mode ON */
        input:checked+.slider {
            background-color: var(--glass-bg);
            border-color: rgba(255, 255, 255, 0.2);
        }

        /* Light Mode ON - Ensure visible stroke */
        body.theme-light input:checked+.slider {
            border: 1px solid rgba(0, 0, 0, 0.2);
            background-color: #f0f0f0;
        }

        input:checked+.slider:before {
            background-color: var(--accent-color);
            transform: translateX(16px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-color);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative;
            background: radial-gradient(circle at 50% 50%, #0a0a0a 0%, #000000 100%);
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Premium Control Panel */
        /* Sidebar Container */
        #controls {
            position: absolute;
            top: 24px;
            left: 24px;
            width: 320px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 24px;
            /* 3x8px */
            border-radius: var(--panel-radius);
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 10;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 48px);
        }

        /* Sidebar Typography & Grid */
        .panel-header {
            margin-bottom: 24px;
            /* 3x8px */
            flex-shrink: 0;
        }

        .panel-title {
            margin: 0 0 8px 0;
            /* 1x8px bottom */
            font-size: 14px;
            font-weight: 800;
            letter-spacing: 0.5px;
            color: var(--text-primary);
            text-transform: uppercase;
        }

        .panel-summary {
            font-size: 11px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .control-section {
            margin-bottom: 24px;
            /* 3x8px */
            position: relative;
        }

        .section-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            /* ~1.5x8px */
            font-size: 11px;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-icon {
            opacity: 0.5;
            cursor: help;
            transition: opacity 0.2s;
            font-size: 12px;
        }

        .info-icon:hover {
            opacity: 1;
        }

        .utilities-footer {
            margin-top: auto;
            /* Push to bottom if height limited, else just flows */
            padding-top: 16px;
            /* 2x8px */
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* Utilities */
        .row-align-center {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        /* Adjust scrollable areas */
        .scroll-y {
            overflow-y: auto;
            /* Custom scrollbar styling if needed */
        }


        /* Form Elements */
        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-weight: 500;
        }

        select,
        input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            transition: all 0.2s ease;
            outline: none;
        }

        select:hover,
        input[type="text"]:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }

        select:focus,
        input[type="text"]:focus {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.2);
        }

        /* Slider */
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            height: 4px;
            border-radius: 2px;
            outline: none;
            margin: 10px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            margin-top: -5px;
            /* Adjust for track centering */
        }

        /* Dual Range Slider Styles */
        .range-slider {
            position: relative;
            width: 100%;
            height: 20px;
            margin-top: 5px;
        }

        .range-slider input[type="range"] {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            pointer-events: none;
            -webkit-appearance: none;
            background: transparent;
            z-index: 2;
        }

        .range-slider input[type="range"]::-webkit-slider-thumb {
            pointer-events: auto;
            position: relative;
            z-index: 3;
            margin-top: 0;
            /* Reset */
        }

        .range-track {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            transform: translateY(-50%);
            z-index: 1;
        }

        .range-progress {
            position: absolute;
            top: 50%;
            height: 4px;
            background: var(--accent-color);
            border-radius: 2px;
            transform: translateY(-50%);
            z-index: 1;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--text-primary);
        }

        .btn:active {
            transform: scale(0.98);
        }

        /* Stats */
        .stats {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-top: 2px;
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(12px);
            padding: 16px 24px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 100;
            width: 440px;
            width: 440px;
            /* display: flex; REMOVED per user request */
            /* flex-direction: row; REMOVED */
            /* align-items: flex-start; REMOVED */
            /* gap: 20px; REMOVED */
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transform: translateY(10px);
        }

        .tooltip-col {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .tooltip-divider {
            width: 1px;
            background: rgba(255, 255, 255, 0.15);
            align-self: stretch;
            margin: 0 4px;
        }

        #tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tooltip-tag {
            font-size: 10px;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .tooltip-title {
            font-weight: 700;
            font-size: 14px;
            line-height: 1.3;
            color: #fff;
            margin-bottom: 2px;
        }

        .tooltip-meta {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .tooltip-meta strong {
            color: #ddd;
        }

        /* Loading */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite;
            margin-bottom: 16px;
        }

        /* Journal List Styles */
        .journal-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            font-size: 11px;
            color: #ccc;
            cursor: pointer;
            border-radius: 4px;
        }

        .journal-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
        }

        .journal-item input {
            accent-color: var(--accent-color);
            width: 12px;
            height: 12px;
            cursor: pointer;
        }

        .loading-text {
            font-size: 14px;
            color: var(--text-secondary);
            letter-spacing: 1px;
            text-transform: uppercase;
            font-weight: 600;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #topicTitle {
            position: absolute;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
            pointer-events: none;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
            z-index: 10;
            display: none;
            background: var(--glass-bg);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        /* --- STITCH UI UPDATES --- */
        .stitch-header-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 200;
            /* Above controls */
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        /* Top Bar */
        .stitch-top-bar {
            height: 64px;
            background-color: #050505;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }

        .stitch-brand {
            font-family: 'Times New Roman', serif;
            /* Editorial feel */
            font-size: 22px;
            color: #fff;
            letter-spacing: -0.01em;
            line-height: 1;
        }

        .stitch-menu {
            display: flex;
            gap: 32px;
        }

        .stitch-menu-link {
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            color: #888;
            text-decoration: none;
            transition: color 0.2s;
        }

        .stitch-menu-link.active,
        .stitch-menu-link:hover {
            color: #fff;
        }

        .stitch-menu-link.active {
            border-bottom: 1px solid #fff;
            padding-bottom: 4px;
        }

        /* Submenu */
        .stitch-sub-bar {
            height: 48px;
            background-color: #0a0a0a;
            /* Slightly lighter than top */
            display: flex;
            align-items: center;
            padding: 0 24px;
            gap: 32px;
            pointer-events: auto;
        }

        .stitch-sub-link {
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            color: #666;
            text-decoration: none;
            font-weight: 500;
        }

        .stitch-sub-link.active {
            color: #fff;
            font-weight: 600;
        }

        .stitch-sub-link:hover {
            color: #ccc;
        }

        /* Breadcrumbs */
        .stitch-breadcrumbs {
            padding: 16px 24px;
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #555;
            pointer-events: auto;
        }

        .stitch-bc-current {
            color: #999;
        }

        /* Info Icon Update */
        .info-icon {
            display: inline-flex !important;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff !important;
            font-size: 10px !important;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            cursor: help;
            margin-left: 6px;
            opacity: 0.7;
        }

        .info-icon:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.4);
        }

        /* Override Controls Position */
        #controls {
            top: 154px !important;
            /* 64 + 48 + 32 + 10 margin */
            left: 24px;
            border-radius: 2px !important;
            /* Sharper */
            background: rgba(10, 10, 10, 0.95) !important;
            /* Darker, less glass */
            border: none !important;
            /* Remove border, cleaner */
            box-shadow: none !important;
            /* Cleaner */
            backdrop-filter: blur(20px);
        }

        /* Typography refinements for Controls */
        .panel-title {
            font-family: 'Times New Roman', serif !important;
            font-size: 18px !important;
            font-weight: 400 !important;
            letter-spacing: 0.02em !important;
            text-transform: uppercase;
        }

        .section-label {
            font-family: 'Inter', sans-serif;
            font-size: 10px !important;
            font-weight: 600 !important;
            letter-spacing: 1px !important;
            color: #666 !important;
        }

        /* Override Topic Title Position (top center label) */
        #topicTitle {
            top: 160px !important;
        }

        /* Hide breadcrumb/nav during loading? No, nice to see context */

        /* --- LAYOUT REFACTOR (Pixel Perfect Stitch Grid) --- */
        #ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            z-index: 200;
        }

        /* 1. Top Bar (Fixed Height) */
        .stitch-top-bar {
            height: 64px;
            background-color: #050505;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            flex-shrink: 0;
            z-index: 201;
        }

        /* 2. Dashboard Area (Fill remaining height) */
        .dashboard-area {
            flex: 1;
            display: flex;
            /* Row: Sidebar | Content */
            overflow: hidden;
            /* Prevent body scroll */
            position: relative;
        }

        /* Left Sidebar Frame - Flush L-Shape */
        .dashboard-sidebar-col {
            width: 320px;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            pointer-events: auto;
            background: var(--l-sidebar-bg);
            border-right: 1px solid var(--l-border);
            z-index: 20;
        }

        /* Right Content Column */
        .dashboard-content-col {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            /* Flexbox text truncation fix */
            pointer-events: none;
            padding: 0;
            /* Header strip handles spacing now */
        }

        /* Layout overrides for single-column views (like Paper Library) */
        .dashboard-content-col.layout-single {
            display: flex !important;
            flex-direction: column !important;
            /* If there was a grid, force single column */
            grid-template-columns: 1fr !important;
        }

        .dashboard-content-col.layout-single .dashboard-view-section {
            padding-left: 0 !important;
            /* Glue to sidebar */
        }

        .dashboard-content-col.layout-single #view-library {
            max-width: none !important;
            width: 100% !important;
            margin: 0 !important;
        }

        /* Dashboard Header Strip - Integrated Glass Bar */
        .dashboard-header-row {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start;

            /* Visuals: Themed Glass Strip */
            background: var(--l-header-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--l-border);

            /* Layout */
            width: 100%;
            padding: 12px 32px;
            margin-bottom: 0;
            z-index: 10;
        }

        /* Submenu - integrated tabs */
        .stitch-sub-bar {
            display: flex;
            align-items: center;
            gap: 32px;
            margin-bottom: 4px;
            padding: 0;
            background: transparent !important;
            /* Force single layer */
            box-shadow: none !important;
        }

        .stitch-sub-link {
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: var(--tab-text);
            text-decoration: none;
            position: relative;
            padding-bottom: 4px;
            transition: all 0.2s ease;
        }

        .stitch-sub-link:hover {
            color: var(--text-primary);
        }

        .stitch-sub-link.active {
            color: var(--tab-text-active);
            font-weight: 600;
        }

        /* Active Underline */
        .stitch-sub-link.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 1px;
            background-color: var(--tab-underline);
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.4);
        }

        /* Breadcrumbs - Muted secondary line */
        .stitch-breadcrumbs {
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--breadcrumb-text);
            margin-top: 4px;
            padding: 0;
            /* Alignment handled by content col */
        }

        /* Controls Panel - Docked (No Card Style) */
        #controls {
            /* Reset absolute positioning */
            position: relative !important;
            top: auto !important;
            left: auto !important;
            width: 100% !important;
            /* Fill sidebar frame */

            /* Height management */
            height: 100% !important;
            max-height: 100% !important;
            overflow-y: hidden;
            display: flex;
            flex-direction: column;
            pointer-events: auto;

            /* Visuals - Reset Card */
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            backdrop-filter: none;
            padding: 0 !important;
        }

        /* Inner scroll container for controls */
        .controls-scroll-content {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            /* Take available space */
            /* Hide scrollbar visually but keep function */
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.1) transparent;
        }

        /* Sticky footer inside controls */
        .utilities-sticky-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--l-border);
            background: var(--l-sidebar-bg);
            /* Themed background */
            /* Opaque to cover scrolling content */
            flex-shrink: 0;
        }

        /* Refine breadcrumbs/submenu text colors for contrast against canvas if transparent */
        .stitch-sub-link {
            color: #888;
        }

        .stitch-sub-link.active {
            color: #fff;
        }

        /* Tweak Topic Title position */
        #topicTitle {
            /* Center vertically in the canvas area roughly? Or top of canvas area? */
            top: 140px !important;
        }

        /* ── Embed Mode: hide all chrome, show only canvas ── */
        body.embed-mode {
            background: transparent !important;
            overflow: hidden;
        }

        body.embed-mode #container {
            background: transparent !important;
        }

        body.embed-mode #ui-layer {
            display: none !important;
        }

        body.embed-mode #zoomControls {
            display: none !important;
        }

        body.embed-mode #topicTitle {
            display: none !important;
        }

        body.embed-mode #loading {
            /* keep spinner but transparent bg */
        }

        /* Disabled Sidebar State */
        .dashboard-sidebar-col.is-disabled {
            opacity: 0.5;
            filter: grayscale(100%);
            position: relative;
        }

        .dashboard-sidebar-col.is-disabled::after {
            content: "Controls disabled in this view";
            position: absolute;
            top: 24px;
            left: 24px;
            right: 24px;
            text-align: center;
            padding: 12px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            z-index: 1000;
            backdrop-filter: blur(4px);
            pointer-events: none;
            /* Let clicks pass through to underneath, although underneath is disabled via pointer-events */
        }

        .dashboard-sidebar-col.is-disabled #controls {
            pointer-events: none;
            /* Disable all interactions */
        }
    </style>
</head>

<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="topicTitle"></div>
    </div>

    <!-- UI OVERLAY LAYER -->
    <div id="ui-layer">

        <!-- 1. Top Navigation Bar (Full Width) -->
        <div class="stitch-top-bar">
            <a href="/" class="stitch-brand" style="text-decoration:none;color:inherit;">Enterprise Policy
                Literacy
                Tool</a>
            <nav class="stitch-menu">
                <a href="/artefact/index.html" class="stitch-menu-link active">Network visualisation</a>
                <a href="/about" class="stitch-menu-link">About the project</a>
                <a href="/policy" class="stitch-menu-link">Policy engagement</a>
                <a href="/contact" class="stitch-menu-link">Contact</a>
            </nav>
        </div>

        <!-- 2. Dashboard Grid (Sidebar + Content) -->
        <div class="dashboard-area">

            <!-- Left Sidebar (Controls) -->
            <div class="dashboard-sidebar-col">
                <div id="controls">
                    <!-- Scrollable Content Wrapper -->
                    <div class="controls-scroll-content">
                        <!-- Header / Compass -->
                        <div class="panel-header">

                            <h3 class="panel-title">NETWORK PANEL</h3>
                            <p class="panel-summary">
                                You’re exploring <strong style="color: var(--text-primary);"><span
                                        id="paperCount">5,776</span></strong> papers, across 40+ journals, mapped
                                into <strong style="color: var(--text-primary);"><span
                                        id="topicCount">25</span></strong> topics and 125 key
                                terms, spanning 1980–2024.
                                <span id="bigramCount" style="display:none"></span>
                            </p>
                        </div>

                        <!-- 1) Start here - Explore mode (Tabs) -->
                        <div class="control-section" style="padding-top:0; margin-bottom: 24px;">
                            <div class="section-label">
                                <span>1) Start here — Explore mode</span>
                                <span class="info-icon"
                                    title="Browse Topics is for exploration and Advanced Search is for targeted queries.">i</span>
                            </div>
                            <div class="tabs-header"
                                style="display: flex; background: var(--input-bg); border-radius: 8px; padding: 2px; border: 1px solid var(--input-border);">
                                <div id="tab-browse" class="tab-btn active" onclick="switchTab('browse')"
                                    style="flex: 1; text-align: center; padding: 6px; font-size: 11px; font-weight: 600; cursor: pointer; border-radius: 6px; background: var(--glass-bg); color: var(--text-primary); transition: all 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                    Browse Topics
                                </div>
                                <div id="tab-search" class="tab-btn" onclick="switchTab('search')"
                                    style="flex: 1; text-align: center; padding: 6px; font-size: 11px; font-weight: 600; cursor: pointer; border-radius: 6px; color: var(--text-secondary); transition: all 0.2s;">
                                    Advanced Search
                                </div>
                            </div>
                        </div>

                        <!-- Tab Content: Browse Topics -->
                        <div id="content-browse" class="tab-content" style="display: block;">

                            <!-- 2) Choose your lens -->
                            <div class="control-section">
                                <div class="section-label">
                                    <span>2) Choose your lens</span>
                                    <span class="info-icon"
                                        title="Select what the network shows: all topics or a specific topic.">i</span>
                                </div>
                                <!-- Existing ID -->
                                <select id="topicSelect">
                                    <option value="all">Macro View (All Topics)</option>
                                </select>
                            </div>

                            <!-- 3) Define your scope -->
                            <div class="control-section">
                                <div class="section-label">
                                    <span>3) Define your scope</span>
                                    <span class="info-icon"
                                        title="Narrow the time window to see how the landscape changes.">i</span>
                                </div>
                                <label
                                    style="font-weight: 400; color: var(--text-secondary); margin-bottom: 4px;">Timeframe:
                                    <span id="yearValue" style="color: var(--accent-color); font-weight: 600;">1980
                                        –
                                        2024</span></label>
                                <div class="range-slider">
                                    <div class="range-track"></div>
                                    <div class="range-progress" id="rangeProgress" style="left: 0%; width: 100%;">
                                    </div>
                                    <input type="range" id="yearSliderStart" min="1980" max="2024" value="1980"
                                        step="1">
                                    <input type="range" id="yearSliderEnd" min="1980" max="2024" value="2024" step="1">
                                </div>
                                <div class="slider-labels">
                                    <span>1980</span>
                                    <span>2024</span>
                                </div>
                            </div>

                            <!-- 4) What to show -->
                            <div class="control-section">
                                <div class="section-label">
                                    <span>4) What to show</span>
                                    <span class="info-icon"
                                        title="These are visual layers, not ranking or recommendations.">i</span>
                                </div>
                                <div
                                    style="margin-bottom: 12px; font-size: 10px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">
                                    Layers</div>

                                <!-- Terms linked to papers -->
                                <div class="row-align-center" style="margin-bottom: 8px;">
                                    <label for="bigramPaperToggle"
                                        style="margin: 0; font-size: 11px; cursor: pointer; color: #ccc;">Terms
                                        linked to
                                        papers</label>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="bigramPaperToggle" checked>
                                        <span class="slider"></span>
                                    </label>
                                </div>

                                <!-- Terms-to-terms link -->
                                <div class="row-align-center">
                                    <label for="bigramToggle"
                                        style="margin: 0; font-size: 11px; cursor: pointer; color: #ccc;">Terms-to-terms
                                        link</label>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="bigramToggle">
                                        <span class="slider"></span>
                                    </label>
                                </div>
                            </div>

                            <!-- 5) Journals -->
                            <div class="control-section">
                                <div class="section-label">
                                    <span>5) Journals</span>
                                    <span class="info-icon"
                                        title="Filter the evidence base without changing the topic model.">i</span>
                                </div>

                                <!-- Multi-select Dropdown UI -->
                                <div style="position: relative;">
                                    <div id="journalDropdownBtn" onclick="toggleJournalDropdown()"
                                        style="padding: 10px; background: var(--input-bg); border: 1px solid var(--input-border); border-radius: 8px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--text-secondary);">
                                        <span>Select Journals</span>
                                        <span style="font-size: 10px; opacity: 0.7;">▼</span>
                                    </div>

                                    <div id="journalDropdownContent"
                                        style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: var(--l-sidebar-bg); border: 1px solid var(--l-border); border-radius: 8px; margin-top: 4px; z-index: 100; box-shadow: 0 4px 20px rgba(0,0,0,0.2); padding: 8px;">
                                        <div style="display: flex; gap: 5px; margin-bottom: 8px;">
                                            <button id="selectAllJournals" class="btn"
                                                style="flex:1; font-size: 10px; padding: 4px;">All</button>
                                            <button id="clearAllJournals" class="btn"
                                                style="flex:1; font-size: 10px; padding: 4px;">None</button>
                                        </div>
                                        <div id="journalList" class="scroll-y" style="max-height: 150px;">
                                            <div
                                                style="padding: 10px; color: #888; text-align: center; font-size: 11px;">
                                                Loading
                                                journals...</div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>
                        <!-- End Tab Content: Browse -->


                        <!-- Tab Content: Advanced Search -->
                        <div id="content-search" class="tab-content"
                            style="display: none; height: 100%; flex-direction: column; overflow: hidden;">
                            <div
                                style="font-size: 10px; color: var(--text-secondary); margin-bottom: 12px; font-style: italic; line-height: 1.4;">
                                Search runs only within this corpus (papers, topics, and extracted terms).
                            </div>

                            <!-- A) Search Input (Tag Enabled) -->
                            <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                                <!-- Tag Container Wrapper -->
                                <div
                                    style="flex: 2; background: rgba(255,255,255,0.1); border: 1px solid var(--glass-border); border-radius: 4px; padding: 4px; display: flex; flex-wrap: wrap; gap: 4px; min-height: 32px;">
                                    <div id="advSearchTags" style="display: contents;"></div>
                                    <input type="text" id="advSearchInput" placeholder="Search..."
                                        style="border: none; background: transparent; color: #fff; font-size: 12px; outline: none; flex: 1; min-width: 60px; padding: 2px;">
                                </div>
                                <select id="advSearchScope" style="flex: 1; font-size: 11px; padding: 0 4px;">
                                    <option value="all">All</option>
                                    <option value="paper">Papers (title)</option>
                                    <option value="author">Authors</option>
                                    <option value="journal">Journals</option>
                                    <option value="term">Terms</option>
                                    <option value="topic">Topics</option>
                                </select>
                            </div>
                            <div style="font-size: 10px; color: #888; margin-bottom: 16px;">Press Enter/Comma to add
                                tag</div>

                            <!-- B) Match Toggle -->
                            <div class="row-align-center"
                                style="justify-content: flex-start; gap: 16px; margin-bottom: 20px;">
                                <label
                                    style="display: flex; align-items: center; gap: 6px; margin: 0; font-weight: 400; cursor: pointer; color: #ccc; font-size: 11px;">
                                    <input type="radio" name="matchType" value="contains" checked style="margin: 0;">
                                    Contains
                                </label>
                                <label
                                    style="display: flex; align-items: center; gap: 6px; margin: 0; font-weight: 400; cursor: pointer; color: #ccc; font-size: 11px;">
                                    <input type="radio" name="matchType" value="exact" style="margin: 0;"> Exact
                                </label>
                            </div>

                            <!-- C) Refine (Collapsible) -->
                            <div
                                style="margin-bottom: 16px; border-bottom: 1px solid var(--glass-border); padding-bottom: 8px;">
                                <div onclick="toggleRefine()"
                                    style="cursor: pointer; font-size: 11px; font-weight: 700; color: var(--text-secondary); padding: 4px 0; display: flex; justify-content: space-between;">
                                    <span>Refine Filters</span>
                                    <span id="refineToggleIcon">+</span>
                                </div>
                                <div id="refineContent" style="display: none; padding-top: 12px;">

                                    <label style="font-size: 10px; color: var(--text-secondary);">Timeframe
                                        constraint</label>
                                    <div class="range-slider" style="margin-top: 2px; margin-bottom: 16px;">
                                        <div class="range-track"></div>
                                        <div class="range-progress" id="advRangeProgress"
                                            style="left: 0%; width: 100%;"></div>
                                        <input type="range" id="advYearSliderStart" min="1980" max="2024" value="1980"
                                            step="1">
                                        <input type="range" id="advYearSliderEnd" min="1980" max="2024" value="2024"
                                            step="1">
                                    </div>

                                    <label style="font-size: 10px; color: var(--text-secondary);">Select
                                        Topic</label>
                                    <select id="advTopicSelect" style="font-size: 11px; margin-bottom: 12px;">
                                        <option value="all">All Topics</option>
                                    </select>

                                    <!-- Simple Journal Multi-select for Refine -->
                                    <label style="font-size: 10px; color: var(--text-secondary);">Journals</label>
                                    <div id="advJournalList" class="scroll-y"
                                        style="max-height: 80px; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px;">
                                        <!-- Populated via JS -->
                                    </div>
                                </div>
                            </div>

                            <!-- D) Results Panel -->
                            <div class="section-label" style="margin-bottom: 8px;">Results</div>
                            <div id="searchResultsPanel" class="scroll-y"
                                style="flex: 1; min-height: 0; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 8px; border: 1px solid rgba(255,255,255,0.05);">
                                <div id="searchResultsCount"
                                    style="font-size: 10px; color: var(--text-secondary); margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                                    Enter search term to begin</div>
                                <div id="searchResultsList" style="display: flex; flex-direction: column; gap: 4px;">
                                </div>
                            </div>

                            <!-- E) Manual Toggle -->
                            <div class="row-align-center" style="margin-top: 16px;">
                                <label style="font-size: 11px; color: var(--text-secondary); margin: 0;">How to
                                    navigate</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="navGuideToggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                        </div>
                        <!-- End Tab Content: Search -->


                        <!-- End Scrollable Content -->
                    </div>

                    <!-- Sticky Footer (Moved outside scroll area) -->
                    <div class="utilities-sticky-footer">
                        <div class="utilities-footer" style="padding-top:0; border:none; margin-top:0;">
                            <div class="row-align-center">
                                <button id="sidebarZoomIn" class="btn" style="flex: 1;">+ Zoom In</button>
                                <div id="zoomPercentage"
                                    style="font-family: monospace; font-size: 12px; color: var(--text-secondary); width: 45px; text-align: center;">
                                    100%</div>
                                <button id="sidebarZoomOut" class="btn" style="flex: 1;">- Zoom Out</button>
                            </div>

                            <button id="resetBtn" class="btn">
                                <span>↺</span> Reset View
                            </button>

                            <div class="row-align-center">
                                <span style="font-size: 11px; color: var(--text-secondary); font-weight: 500;">Grey/Dark
                                    mode</span>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="themeToggle" checked>
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <input type="hidden" id="searchInput" value="">
                        </div>
                    </div>
                </div> <!-- End #controls -->
            </div> <!-- End Sidebar Col -->

            <!-- Right Content Column (Header + Canvas View) -->
            <div class="dashboard-content-col">
                <!-- Dashboard Helper Header -->
                <div class="dashboard-header-row">
                    <div class="stitch-sub-bar">
                        <a href="#" id="nav-network" class="stitch-sub-link active"
                            onclick="switchView('network'); return false;">Network View</a>
                        <a href="#" class="stitch-sub-link">Field Structure</a>
                        <a href="#" id="nav-temporal" class="stitch-sub-link"
                            onclick="switchView('temporal'); return false;">Temporal Evolution</a>
                        <a href="#" id="nav-library" class="stitch-sub-link"
                            onclick="switchView('library'); return false;">Paper Library</a>
                    </div>
                    <div class="stitch-breadcrumbs">
                        <span style="opacity: 0.6; margin-right: 5px; font-weight: 400;">You are here:</span>
                        <a href="#" onclick="goHome(); return false;"
                            style="color: inherit; text-decoration: none; font-weight: 600;">NETWORK
                            VISUALISATION</a>
                        <span style="margin: 0 6px; opacity: 0.6;">/</span>
                        <span class="stitch-bc-current">NETWORK VIEW</span>
                    </div>
                </div>

                <!-- Canvas Interaction Layer (Empty, just reserves space if needed, 
                 but canvas is bg so we let it be) -->
                <!-- Temporal View Overlay -->
                <div id="view-temporal" class="dashboard-view-section custom-scrollbar" style="display: none;">
                    <div style="max-width: 900px; margin: 0 auto; padding-bottom: 40px;">

                        <!-- Card 1: Corpus Growth (Placeholder) -->
                        <div class="stitch-card">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <div class="stitch-card-title">Corpus Growth</div>
                                <div
                                    style="font-size:10px; font-weight:600; color:var(--text-secondary); border:1px solid var(--input-border); padding:3px 8px; border-radius:12px; cursor:default; letter-spacing:0.05em; opacity:0.9;">
                                    ANNUAL
                                </div>
                            </div>
                            <div class="stitch-card-subtitle">Shows how the volume of policy research has expanded
                                over
                                the analysis period.</div>
                            <div id="corpus-growth-chart"
                                style="height: 200px; display:flex; align-items:center; justify-content:center; background:var(--input-bg); color:var(--text-secondary); border-radius:4px;">
                                [Corpus Growth Bar Chart Placeholder]
                            </div>
                        </div>

                        <!-- Card 2: Topic Prevalence -->
                        <div class="stitch-card">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <div class="stitch-card-title">Topic Prevalence Over Time</div>
                                <div onclick="openTemporalModal()"
                                    style="font-size:16px; cursor:pointer; color:var(--text-secondary); padding:4px;"
                                    title="Expand View">⛶</div>
                            </div>
                            <div class="stitch-card-subtitle">Longitudinal shift in thematic priorities as a
                                percentage
                                of total annual corpus.</div>

                            <div id="topic-prevalence-chart"></div> <!-- Chart renders here -->

                            <!-- Legend Container -->
                            <div id="topic-prevalence-legend"
                                style="display:flex; flex-wrap:wrap; gap:16px; margin-top:24px; justify-content:center; padding-top:16px; border-top:1px solid var(--l-border);">
                            </div>
                        </div>

                        <!-- Card 3: Emerging vs Declining (Placeholder) -->
                        <div class="stitch-card">
                            <div class="stitch-card-title">Emerging vs Declining Topics</div>
                            <div class="stitch-card-subtitle">Comparative shift in topic share between the first and
                                last decade of the dataset.</div>
                            <div id="emerging-declining-container"
                                style="height: auto; min-height: fit-content; overflow: visible; display:flex; align-items:flex-start; justify-content:center; background:transparent; color:var(--text-secondary); border-radius:4px; gap: 16px;">
                                [Emerging/Declining Table Placeholder]
                            </div>
                        </div>

                        <!-- Card 4: Topic Trends (All Topics) -->
                        <div class="stitch-card">
                            <div class="stitch-card-title">Topic trends over time (all topics)</div>

                            <!-- Header Row: Subtitle + Dropdown -->
                            <div class="stitch-card-header-row"
                                style="display:flex; justify-content:space-between; align-items:flex-start; gap:16px; margin-bottom:16px;">
                                <div class="stitch-card-subtitle" style="margin-bottom:0; flex:1;">
                                    1980–2025 (hover to isolate a topic)
                                </div>
                                <div id="chart4-topic-selector"
                                    style="position:relative; min-width:200px; flex-shrink:0;"></div>
                            </div>

                            <!-- Tags Container -->
                            <div id="chart4-topic-tags"
                                style="display:flex; flex-wrap:wrap; gap:8px; margin-bottom:24px;">
                                <!-- Tags injected here -->
                            </div>

                            <!-- Chart Wrapper -->
                            <div id="topic-trends-chart" style="height: 400px; width: 100%; position: relative;">
                                <div
                                    style="height:100%; display:flex; align-items:center; justify-content:center; color:var(--text-secondary); opacity:0.7;">
                                    Loading trends...
                                </div>
                            </div>
                            <div id="topic-trends-legend"
                                style="margin-top:16px; min-height:20px; font-size:12px; color:var(--text-primary); text-align:center;">
                                &nbsp;
                            </div>
                        </div>

                        <!-- Card 5: Bigram Trends (Chart 5) -->
                        <div class="stitch-card">
                            <div class="stitch-card-title">Bigram trends over time (selected topic)</div>
                            <div
                                style="display:flex; justify-content:space-between; align-items:flex-start; gap:16px; margin-bottom:16px;">
                                <div class="stitch-card-subtitle" style="margin-bottom:0; flex:1;">
                                    1980–2025 (top 5 bigrams)
                                </div>
                                <div id="chart5-topic-selector"
                                    style="position:relative; min-width:200px; flex-shrink:0;">
                                    <!-- JS injects dropdown here -->
                                    <div style="font-size:11px; color:var(--text-secondary);">Loading topics...
                                    </div>
                                </div>
                            </div>

                            <!-- Chart Wrapper -->
                            <div id="bigram-trends-chart" style="height: 400px; width: 100%; position: relative;">
                                <div
                                    style="height:100%; display:flex; align-items:center; justify-content:center; color:var(--text-secondary); opacity:0.7;">
                                    Select a topic to view trends...
                                </div>
                            </div>
                            <div id="bigram-trends-legend"
                                style="margin-top:16px; min-height:20px; font-size:12px; color:var(--text-primary); text-align:center;">
                                &nbsp;
                            </div>
                        </div>
                    </div>
                </div> <!-- End #view-temporal -->

                <!-- Paper Library View -->
                <div id="view-library" class="dashboard-view-section custom-scrollbar" style="display: none;">
                    <div style="padding-bottom: 40px;">
                        <div class="stitch-card">
                            <div class="stitch-card-title"
                                style="margin-bottom: 24px; display: flex; justify-content: space-between; align-items: center;">
                                <span>Paper Library &mdash; <span id="library-total-count">0 papers</span></span>
                            </div>

                            <!-- Controls: Search -->
                            <div style="margin-bottom: 24px;">
                                <input type="text" id="library-search" class="stitch-input"
                                    placeholder="Search title, author, or journal..."
                                    style="width: 100%; max-width: 400px;"
                                    oninput="if(typeof LibraryManager !== 'undefined'){ LibraryManager.searchQuery = this.value; LibraryManager.applyFilters(); }">
                            </div>

                            <!-- Table -->
                            <div style="overflow-x: auto;">
                                <table id="paper-library-table"
                                    style="width: 100%; border-collapse: collapse; margin-top: 16px;">
                                    <thead>
                                        <tr style="border-bottom: 1px solid var(--chart-panel-border);">
                                            <th style="cursor:pointer; text-align: left; padding: 10px 12px; color: var(--text-secondary); font-size: 11px; width: 60px; transition: color 0.2s;"
                                                onclick="if(typeof LibraryManager !== 'undefined') LibraryManager.sort('year')">
                                                Year <span id="sort-icon-year" style="font-size:10px;">▼</span></th>
                                            <th style="cursor:pointer; text-align: left; padding: 10px 12px; color: var(--text-secondary); font-size: 11px; width: 55%; transition: color 0.2s;"
                                                onclick="if(typeof LibraryManager !== 'undefined') LibraryManager.sort('title')">
                                                Title <span id="sort-icon-title" style="font-size:10px;"></span></th>
                                            <th style="cursor:pointer; text-align: left; padding: 10px 12px; color: var(--text-secondary); font-size: 11px; width: 20%; transition: color 0.2s;"
                                                onclick="if(typeof LibraryManager !== 'undefined') LibraryManager.sort('authors')">
                                                Author(s) <span id="sort-icon-authors" style="font-size:10px;"></span>
                                            </th>
                                            <th style="cursor:pointer; text-align: left; padding: 10px 12px; color: var(--text-secondary); font-size: 11px; width: 20%; transition: color 0.2s;"
                                                onclick="if(typeof LibraryManager !== 'undefined') LibraryManager.sort('journal')">
                                                Journal <span id="sort-icon-journal" style="font-size:10px;"></span>
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody id="paper-library-tbody">
                                        <!-- Rows populated via JS -->
                                    </tbody>
                                </table>
                            </div>

                            <!-- Pagination -->
                            <div
                                style="display: flex; justify-content: center; align-items: center; gap: 16px; margin-top: 24px;">
                                <button id="lib-prev-btn" class="btn" style="width: auto; padding: 6px 16px;"
                                    onclick="if(typeof LibraryManager !== 'undefined') LibraryManager.changePage(-1)"
                                    disabled>Previous</button>
                                <span id="lib-page-info" style="font-size: 13px; color: var(--text-secondary);">Page 1
                                    of 1</span>
                                <button id="lib-next-btn" class="btn" style="width: auto; padding: 6px 16px;"
                                    onclick="if(typeof LibraryManager !== 'undefined') LibraryManager.changePage(1)"
                                    disabled>Next</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Individual Topic Dashboard -->
                <div id="view-topic" class="dashboard-view-section custom-scrollbar" style="display: none;">
                    <div style="max-width: 1400px; margin: 0 auto; padding-bottom: 40px;">

                        <!-- Header Region: Two-Column (Topic Brief + Network Graph) -->
                        <div style="display: grid; grid-template-columns: 350px 1fr; gap: 24px; margin-bottom: 24px;">
                            <!-- Left: Topic Brief -->
                            <div class="stitch-card" style="margin-bottom: 0; display: flex; flex-direction: column;">
                                <div class="stitch-card-title" id="topic-brief-title">Loading...</div>
                                <div class="stitch-card-subtitle" id="topic-brief-subtitle"
                                    style="margin-bottom: 16px;">
                                    Topic definition</div>
                                <div id="topic-brief-definition"
                                    style="color: var(--text-primary); font-size: 14px; line-height: 1.6; flex: 1;">
                                    Loading definition...
                                </div>
                            </div>

                            <!-- Right: Network Graph Card -->
                            <div class="stitch-card"
                                style="margin-bottom: 0; padding: 0; height: 500px; position: relative; overflow: hidden; background: var(--bg-color);">
                                <!-- Canvas Container -->
                                <div id="topic-network-container" style="width:100%; height:100%;">
                                    <div
                                        style="position: absolute; bottom: 16px; right: 16px; display: flex; flex-direction: column; gap: 8px; z-index: 10;">
                                        <button id="topic-zoom-in" class="btn"
                                            style="width: 32px; height: 32px; padding: 0; display: flex; align-items: center; justify-content: center;">+</button>
                                        <button id="topic-zoom-out" class="btn"
                                            style="width: 32px; height: 32px; padding: 0; display: flex; align-items: center; justify-content: center;">-</button>
                                    </div>
                                </div> <!-- D3 Canvas will be moved here -->
                            </div>
                        </div>
                    </div>

                    <!-- Top Terms -->
                    <div class="stitch-card">
                        <div class="stitch-card-title">Top terms shaping this topic</div>
                        <div id="topic-top-terms" style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 16px;">
                            <!-- Chips injected here -->
                        </div>
                    </div>

                    <!-- Bigram Trends -->
                    <div class="stitch-card">
                        <div class="stitch-card-title" id="topic-trends-title">Bigram trends over time</div>
                        <div class="stitch-card-subtitle">Tracks how the topic’s five defining terms rise and
                            fall
                            across the corpus timeline.</div>
                        <div id="topic-trends-chart-container" style="height: 300px; width: 100%;"></div>
                    </div>

                    <!-- Papers Table -->
                    <div class="stitch-card">
                        <div class="stitch-card-title" id="topic-papers-title">Papers informing this topic</div>
                        <div style="overflow-x: auto;">
                            <table id="topic-papers-table"
                                style="width: 100%; border-collapse: collapse; margin-top: 16px;">
                                <thead>
                                    <tr style="border-bottom: 1px solid var(--chart-panel-border);">
                                        <th
                                            style="text-align: left; padding: 12px; color: var(--text-secondary); font-size: 12px;">
                                            Year</th>
                                        <th
                                            style="text-align: left; padding: 12px; color: var(--text-secondary); font-size: 12px; width: 40%;">
                                            Title</th>
                                        <th
                                            style="text-align: left; padding: 12px; color: var(--text-secondary); font-size: 12px;">
                                            Author(s)</th>
                                        <th
                                            style="text-align: left; padding: 12px; color: var(--text-secondary); font-size: 12px;">
                                            Journal</th>
                                        <th style="width: 40px;"></th>
                                    </tr>
                                </thead>
                                <tbody id="topic-papers-tbody"></tbody>
                            </table>
                        </div>

                        <!-- Pagination -->
                        <div id="topic-papers-pagination"
                            style="display: flex; justify-content: center; align-items: center; gap: 16px; margin-top: 24px;">
                            <button id="papers-prev-btn" class="btn" style="width: auto;">Previous</button>
                            <div id="papers-page-info" style="color: var(--text-secondary); font-size: 13px;">
                                Page 1
                            </div>
                            <button id="papers-next-btn" class="btn" style="width: auto;">Next</button>
                        </div>
                    </div>

                    <!-- Topic Navigation -->
                    <div style="display: flex; justify-content: space-between; margin-top: 32px;">
                        <button id="prev-topic-btn" class="btn" style="width: auto;">← Previous Topic</button>
                        <button id="next-topic-btn" class="btn" style="width: auto;">Next Topic →</button>
                    </div>
                </div>
            </div>

        </div> <!-- End Dashboard Content Col -->

    </div> <!-- End Dashboard Area -->
    </div> <!-- End UI Layer -->



    <!-- Temporal Chart Modal -->
    <div id="temporal-modal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:9999; align-items:center; justify-content:center; padding:40px;">
        <div
            style="background:var(--l-sidebar-bg); width:90%; height:90%; max-width:1400px; border-radius:12px; padding:32px; display:flex; flex-direction:column; position:relative; box-shadow:0 8px 32px rgba(0,0,0,0.5); border:1px solid var(--l-border);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
                <div>
                    <h3 style="margin:0 0 4px 0; color:var(--text-primary); font-size:24px;">Topic Prevalence Over
                        Time</h3>
                    <p style="margin:0; color:var(--text-secondary); font-size:14px;">Expanded View</p>
                </div>
                <div onclick="closeTemporalModal()"
                    style="color:var(--text-secondary); cursor:pointer; font-size:32px; line-height:1; font-weight:bold; padding:8px;">
                    &times;</div>
            </div>
            <div id="modal-chart-container" style="flex:1; width:100%; min-height:0; position:relative;"></div>
            <div id="modal-legend-container"
                style="display:flex; flex-wrap:wrap; gap:24px; margin-top:24px; justify-content:center; padding-top:16px; border-top:1px solid var(--l-border); max-height:120px; overflow-y:auto;">
            </div>
        </div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div class="loading-text" style="text-align: center; white-space: normal;">Assembling the policy research
            galaxy...</div>
    </div>

    <div id="zoomControls">
        <button id="zoomIn" class="zoom-btn">+</button>
        <button id="zoomOut" class="zoom-btn">−</button>
    </div>


    <style>
        #zoomControls {
            position: absolute;
            bottom: 24px;
            right: 24px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        /* Temporal View Styles */
        .dashboard-view-section {
            flex: 1;
            overflow-y: auto;
            padding: 32px;
            background: var(--bg-color);
            z-index: 50;
            pointer-events: auto;
        }

        /* Custom Scrollbar for view */
        .dashboard-view-section::-webkit-scrollbar {
            width: 8px;
        }

        .dashboard-view-section::-webkit-scrollbar-track {
            background: transparent;
        }

        .dashboard-view-section::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .stitch-card {
            background: var(--l-sidebar-bg);
            border: 1px solid var(--l-border);
            border-radius: var(--panel-radius);
            padding: 32px;
            margin-bottom: 24px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.05);
            /* Subtle lift */
        }

        .stitch-card-title {
            font-family: 'Inter', sans-serif;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-primary);
            letter-spacing: -0.02em;
        }

        .stitch-card-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 24px;
            font-style: italic;
            line-height: 1.4;
        }

        #topic-prevalence-chart {
            width: 100%;
            height: 400px;
        }
    </style>

    <div id="tooltip" style="z-index: 20000000; pointer-events: none;"></div>

    <script>
        console.log('🎨 Enterprise Policy Literacy Network Visualization');
        console.log('📊 Session 1: Macro circular chord diagram');

        // Supabase configuration
        const SUPABASE_URL = 'https://szyhygctrotfysldfemh.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN6eWh5Z2N0cm90ZnlzbGRmZW1oIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkwMDQ5MjcsImV4cCI6MjA4NDU4MDkyN30.ixuEt2C0b4fCoUES_6LIN_vaQKOzEyOjQulIikV2vmg';

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const loading = document.getElementById('loading');

        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        // Enhanced Palette per request
        const topicColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52B788',
            '#E76F51', '#2A9D8F', '#E9C46A', '#F4A261', '#264653',
            '#D62828', '#003049', '#F77F00', '#06FFA5', '#7209B7',
            '#560BAD', '#3A0CA3', '#4361EE', '#4CC9F0', '#FF006E'
        ];

        // URL Configuration Parser
        const urlParams = new URLSearchParams(window.location.search);
        const isEmbedMode = urlParams.get('embed') === 'true';
        const urlState = {
            mode: urlParams.get('mode') || 'macro', // 'macro' | 'topic'
            topicId: parseInt(urlParams.get('topicId')) || null
        };

        // Apply embed mode class immediately
        if (isEmbedMode) {
            document.body.classList.add('embed-mode');
        }

        console.log('🔗 URL Configuration:', urlState, 'Embed:', isEmbedMode);

        // Data storage
        let allData = {
            topics: [],
            bigrams: [],
            papers: []
        };
        window.allData = allData; // Expose for debugging/external access

        let currentView = 'macro';
        let showBigramNetwork = false;
        let showBigramPaperConnections = true; // New state (Default ON)
        let isRingView = false;
        let animationFrame = null;
        let selectedNode = null;




        let minYear = 1980;
        let maxYear = 2024;
        let searchTerm = ''; // For search filtering

        // Navigation Transform
        let transform = d3.zoomIdentity;
        let selectedJournals = new Set(); // Multi-select filter

        // Initialize Zoom Behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on("zoom", (e) => {
                transform = e.transform;
                hideTooltip(); // Dismiss tooltip on pan/zoom

                // Update Zoom Percentage Indicator
                const percent = Math.round(transform.k * 100);
                const indicator = document.getElementById('zoomPercentage');
                if (indicator) indicator.textContent = `${percent}%`;

                // No need to explicitly call draw, animation loop handles it
            });

        // Node Drag Behavior (Topic Mode Only)
        const dragNode = d3.drag()
            .subject(dragSubject)
            .on("start", dragStarted)
            .on("drag", dragged)
            .on("end", dragEnded);

        function dragSubject(event) {
            // Only active in topic mode
            if (urlState.mode !== 'topic') return null;

            // Calculate mouse position in simulation coordinates
            const x = (event.x - transform.x) / transform.k;
            const y = (event.y - transform.y) / transform.k;

            let subject = null;
            let minDistSq = Infinity;
            const detectionRadius = 30; // Generous hit area (simulation spacing)

            // Prioritize Bigrams
            for (let i = 0; i < allData.bigrams.length; i++) {
                const b = allData.bigrams[i];
                const dx = x - b.x;
                const dy = y - b.y;
                const d2 = dx * dx + dy * dy;
                if (d2 < detectionRadius * detectionRadius && d2 < minDistSq) {
                    minDistSq = d2;
                    subject = b;
                }
            }

            // Then Papers if no bigram found
            if (!subject) {
                for (let i = 0; i < allData.papers.length; i++) {
                    const p = allData.papers[i];
                    const dx = x - p.x;
                    const dy = y - p.y;
                    const d2 = dx * dx + dy * dy;
                    if (d2 < detectionRadius * detectionRadius && d2 < minDistSq) {
                        minDistSq = d2;
                        subject = p;
                    }
                }
            }

            return subject;
        }

        function dragStarted(event) {
            // Restart simulation if it exists
            if (!event.active && typeof simulation !== 'undefined' && simulation) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
            canvas.style.cursor = 'grabbing';
        }

        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        function dragEnded(event) {
            if (!event.active && typeof simulation !== 'undefined' && simulation) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
            canvas.style.cursor = 'default';
        }

        d3.select(canvas).call(dragNode).call(zoom)
            // Disable double click zoom
            .on("dblclick.zoom", null);

        // Helper to update loading status
        function updateStatus(msg) {
            const statusEl = document.querySelector('.loading-text');
            if (statusEl) statusEl.innerHTML = msg;
            console.log(`state: ${msg.replace(/<[^>]*>/g, '')}`);
        }

        // Demo Data Fallback
        function getDemoData() {
            const topics = Array.from({ length: 10 }, (_, i) => ({
                id: i + 1,
                topic_name: `Demo Topic ${i + 1}`,
                name: `Demo Topic ${i + 1}`
            }));

            const bigrams = Array.from({ length: 30 }, (_, i) => ({
                id: i + 1,
                topic_id: (i % 10) + 1,
                bigram: `bigram_${i}`,
                normalized_frequency: Math.random()
            }));

            const papers = Array.from({ length: 100 }, (_, i) => ({
                id: i + 1,
                title: `Demo Paper ${i + 1}`,
                authors: `Author A, Author B`,
                year: 2020 + (i % 5),
                journal: 'Journal of Entrepreneurship'
            }));

            const topicPaperLinks = papers.map((p, i) => ({
                paper_id: p.id,
                topic_id: (i % 10) + 1
            }));

            return { topics, bigrams, papers, topicPaperLinks };
        }

        // Helper function to fetch from Supabase
        async function fetchFromSupabase(table, limit = null, range = null) {
            let url = `${SUPABASE_URL}/rest/v1/${table}?select=*`;
            if (limit) {
                url += `&limit=${limit}`;
            }

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

            try {
                const headers = {
                    'apikey': SUPABASE_KEY,
                    'Authorization': `Bearer ${SUPABASE_KEY}`,
                    'Content-Type': 'application/json',
                    'Prefer': 'return=representation'
                };

                if (range) {
                    headers['Range'] = range;
                }

                const response = await fetch(url, {
                    headers: headers,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                return await response.json();
            } catch (err) {
                if (err.name === 'AbortError') throw new Error('Connection timed out.');
                throw err;
            }
        }

        // Load data
        async function loadData(useDemo = false) {
            try {
                console.log('🚀 Starting data load...');
                loading.style.display = 'flex'; // Ensure visible on retry

                let topics, bigrams, papers, topicPaperLinks;

                if (useDemo) {
                    updateStatus('Assembling the policy research galaxy...<br><span style="font-size:12px; opacity:0.7">Generating demo data...</span>');
                    await new Promise(r => setTimeout(r, 800)); // Fake delay
                    const demo = getDemoData();
                    topics = demo.topics;
                    bigrams = demo.bigrams;
                    papers = demo.papers;
                    topicPaperLinks = demo.topicPaperLinks;
                } else {
                    updateStatus('Assembling the policy research galaxy...<br><span style="font-size:12px; opacity:0.7">Connecting to database...</span>');
                    topics = await fetchFromSupabase('topics');
                    updateStatus('Assembling the policy research galaxy...<br><span style="font-size:12px; opacity:0.7">Loaded topics...</span>');

                    bigrams = await fetchFromSupabase('bigrams');
                    updateStatus('Assembling the policy research galaxy...<br><span style="font-size:12px; opacity:0.7">Loaded bigrams...</span>');

                    // Paginate papers to fetch all
                    papers = [];
                    let page = 0;
                    const pageSize = 1000;
                    let fetching = true;

                    while (fetching) {
                        const start = page * pageSize;
                        const end = start + pageSize - 1;
                        updateStatus(`Assembling the policy research galaxy...<br><span style="font-size:12px; opacity:0.7">Loading papers computation (${start} - ${end})</span>`);

                        const batch = await fetchFromSupabase('papers', null, `${start}-${end}`);

                        // Check if we got data
                        if (batch.length === 0) {
                            fetching = false;
                        } else {
                            papers = papers.concat(batch);
                            if (batch.length < pageSize) {
                                fetching = false;
                            } else {
                                page++;
                            }
                        }
                    }
                    console.log(`✅ Loaded ${papers.length} papers total`);
                    updateStatus(`Assembling the policy research galaxy...<br><span style="font-size:12px; opacity:0.7">Loaded ${papers.length} papers...</span>`);

                    topicPaperLinks = await fetchFromSupabase('topic_paper_links');
                    updateStatus('Assembling the policy research galaxy...<br><span style="font-size:12px; opacity:0.7">Finalizing network...</span>');
                }

                // Process data
                allData.topics = topics.map((t, i) => ({
                    ...t,
                    type: 'topic',
                    id: t.id ? Number(t.id) : (i + 1), // Validation
                    color: topicColors[i % topicColors.length],
                    x: 0,
                    y: 0,
                    radius: 12,
                    topic_name: t.topic_name || t.name || `Topic ${t.id}`
                }));

                // Helper for text capitalization
                const capitalizeText = (text) => {
                    if (!text) return '';
                    return text.charAt(0).toUpperCase() + text.slice(1);
                };

                // Helper for Journal Title Case (optional, but "Science and Public Policy" looks better than "Science and public policy")
                const formatJournal = (text) => {
                    if (!text) return 'N/A';
                    // Simple Sentence case as requested ("Capitalise the first letter")
                    // Use this if strict "first letter only" is desired.
                    // However, usually Journals are Title Case. User example 'Science' is ambiguous.
                    // For 'Government subsidies...' (title) -> Sentence case.
                    // I will stick to Sentence Case (first letter capitalized) for both as strictly requested.
                    return text.charAt(0).toUpperCase() + text.slice(1);
                };

                allData.bigrams = bigrams.map(b => ({
                    ...b,
                    type: 'bigram',
                    color: topicColors[(b.topic_id - 1) % topicColors.length],
                    x: 0,
                    y: 0,
                    radius: Math.max(14, 16 + (b.normalized_frequency || 0) * 45)  // Increased by another ~40% (Total ~2x original)
                }));

                // Create a map of paper_id -> topic_id from links
                const paperTopicMap = {};
                topicPaperLinks.forEach(link => {
                    if (!paperTopicMap[link.paper_id]) {
                        paperTopicMap[link.paper_id] = link.topic_id;
                    }
                });

                // Infer bigram-paper connections: papers connect to their topic's bigrams
                // Each paper connects to 2-3 random bigrams from its topic
                const paperBigramMap = {};

                allData.papers = papers.map((p, index) => {
                    // Get topic from link, or distribute evenly if no link
                    let topicId = paperTopicMap[p.id] || ((index % 25) + 1);

                    // Get bigrams for this topic
                    const topicBigramIds = allData.bigrams
                        .filter(b => b.topic_id === topicId)
                        .map(b => b.id);

                    // Randomly select 2-3 bigrams for this paper
                    const numBigrams = Math.min(2 + Math.floor(Math.random() * 2), topicBigramIds.length);
                    const selectedBigrams = [];
                    for (let i = 0; i < numBigrams; i++) {
                        const randomIdx = Math.floor(Math.random() * topicBigramIds.length);
                        selectedBigrams.push(topicBigramIds[randomIdx]);
                    }

                    return {
                        ...p,
                        type: 'paper',
                        // clean data
                        title: capitalizeText(p.title || 'Untitled'),
                        journal: formatJournal(p.journal || p.source_title || ''),
                        color: topicColors[(topicId - 1) % topicColors.length],
                        topicId: topicId,
                        bigramIds: selectedBigrams,  // Inferred connections
                        x: 0,
                        y: 0,
                        vx: (Math.random() - 0.5) * 0.1,  // Slow movement
                        vy: (Math.random() - 0.5) * 0.1,
                        radius: 2.0 + Math.random() * 1.3
                    };
                });

                // Store links
                allData.links = topicPaperLinks;

                const papersWithBigrams = allData.papers.filter(p => p.bigramIds.length > 0).length;
                console.log(`🎨 Papers with bigram connections: ${papersWithBigrams}/${allData.papers.length}`);

                // Populate dropdown
                const select = document.getElementById('topicSelect');
                select.innerHTML = '<option value="all">Macro View (All Topics)</option>';

                allData.topics.forEach((topic, index) => {
                    // Critical Validation for Dropdown
                    if (typeof topic.id !== 'number' || isNaN(topic.id)) {
                        console.error("Invalid topic object encountered during dropdown population:", topic);
                        return;
                    }

                    const option = document.createElement('option');
                    // Enforce numeric ID from DB or fallback to index+1
                    option.value = topic.id;

                    // Forces format: "Topic X: Name"
                    const rawName = topic.topic_name || topic.name || 'Unnamed Topic';
                    const cleanName = rawName.replace(/^Topic \d+:\s*/, '').replace(/^Topic undefined:\s*/, '');
                    option.textContent = `Topic ${topic.id}: ${cleanName}`; // Use ID in label for consistency
                    select.appendChild(option);
                });

                // MANDATORY VERIFICATION STEP
                const dropdownVerification = [...document.querySelectorAll("#topicSelect option")]
                    .map(o => ({
                        text: o.textContent,
                        value: o.value,
                        numericValue: Number(o.value),
                        isValid: !isNaN(Number(o.value)) || o.value === 'all'
                    }));
                console.table(dropdownVerification); // Log to console for debugging

                // POPULATE JOURNAL FILTER
                const uniqueJournals = [...new Set(allData.papers.map(p => p.journal || 'Unknown'))].sort();
                // Initialize all as selected
                uniqueJournals.forEach(j => selectedJournals.add(j));

                const journalList = document.getElementById('journalList');
                journalList.innerHTML = ''; // Clear loading

                uniqueJournals.forEach(j => {
                    const div = document.createElement('div');
                    div.className = 'journal-item';
                    div.innerHTML = `
                            <input type="checkbox" id="j-${j.replace(/\s+/g, '')}" value="${j}" checked>
                            <label for="j-${j.replace(/\s+/g, '')}" style="margin:0; width:100%; cursor:pointer; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;" title="${j}">${j}</label>
                        `;
                    div.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'INPUT') {
                            const cb = div.querySelector('input');
                            cb.checked = !cb.checked;
                            cb.dispatchEvent(new Event('change'));
                        }
                    });

                    // Change listener
                    div.querySelector('input').addEventListener('change', (e) => {
                        if (e.target.checked) selectedJournals.add(j);
                        else selectedJournals.delete(j);
                    });

                    journalList.appendChild(div);
                });

                // Journal Filter Buttons
                document.getElementById('selectAllJournals').addEventListener('click', () => {
                    uniqueJournals.forEach(j => selectedJournals.add(j));
                    document.querySelectorAll('#journalList input').forEach(cb => cb.checked = true);
                });

                document.getElementById('clearAllJournals').addEventListener('click', () => {
                    selectedJournals.clear();
                    document.querySelectorAll('#journalList input').forEach(cb => cb.checked = false);
                });

                // TOPIC MODE ISOLATION (Hard Scope)
                if (urlState.mode === 'topic' && urlState.topicId) {
                    const tId = urlState.topicId;
                    console.log(`🔒 ENFORCING TOPIC MODE: Isolating Topic ${tId}`);

                    // 1. Filter Topics (Keep only selected)
                    const topicExists = allData.topics.some(t => t.id === tId);
                    if (!topicExists) {
                        console.error(`❌ Topic ${tId} found in URL but not in data. Fallback to Macro.`);
                    } else {
                        // Save all topics for navigation before filtering
                        window.globalAllTopics = [...allData.topics];
                        allData.topics = allData.topics.filter(t => t.id === tId);

                        // 2. Filter Bigrams (Keep only belonging to topic)
                        const validBigramIds = new Set();
                        allData.bigrams = allData.bigrams.filter(b => {
                            const isValid = b.topic_id === tId;
                            if (isValid) validBigramIds.add(b.id);
                            return isValid;
                        });

                        // 3. Filter Papers (Keep only connected to valid bigrams or topic directly)
                        allData.papers = allData.papers.filter(p => {
                            const linkedToBigram = p.bigramIds && p.bigramIds.some(bid => validBigramIds.has(bid));
                            const linkedToTopic = p.topicId === tId;
                            return linkedToBigram || linkedToTopic;
                        });

                        // 4. Update Links
                        allData.links = allData.links.filter(l => l.topic_id === tId);

                        console.log(`✅ Micro-Galaxy Loaded: 1 Topic, ${allData.bigrams.length} Bigrams, ${allData.papers.length} Papers`);

                        // Set Title - Explicitly for Micro View
                        if (allData.topics.length > 0) {
                            const t = allData.topics[0];
                            const titleEl = document.getElementById('topicTitle');
                            const rawName = t.topic_name || t.name || 'Unnamed Topic';
                            const cleanName = rawName.replace(/^Topic \d+:\s*/, '').replace(/^Topic undefined:\s*/, '');
                            titleEl.textContent = `Topic ${t.id}: ${cleanName}`;
                            titleEl.style.display = 'block';

                            // --- SYNC UI STATES ---
                            // 1. Dropdown
                            const topicSelect = document.getElementById('topicSelect');
                            if (topicSelect) topicSelect.value = t.id;

                            // 2. Breadcrumbs
                            const breadcrumbs = document.querySelector('.stitch-breadcrumbs');
                            if (breadcrumbs) {
                                breadcrumbs.innerHTML = `<span style="opacity: 0.6; margin-right: 5px; font-weight: 400;">You are here:</span> <a href="#" onclick="goHome(); return false;" style="color: inherit; text-decoration: none; font-weight: 600;">NETWORK VISUALISATION</a> <span style="margin: 0 6px; opacity: 0.6;">/</span> <span class="stitch-bc-current">TOPIC ${t.id}: ${cleanName}</span>`;
                            }
                        }
                    }
                } else {
                    console.log(`🌍 Macro Mode Loaded: ${allData.topics.length} Topics`);
                    // Hide title in Macro Mode
                    const titleEl = document.getElementById('topicTitle');
                    if (titleEl) titleEl.style.display = 'none';
                }

                updateStats();
                loading.style.display = 'none';

                console.log('🎨 Initializing visualization...');
                computeBigramLinks(); // Generate bigram network


                if (urlState.mode === 'topic') {
                    await initIndividualTopicDashboard();
                    initMacroView();
                    animate();
                } else {
                    initMacroView();
                    animate();
                }

            } catch (error) {
                console.error('💥 Error:', error);
                loading.innerHTML = `
                    <div style="color: #ff6b6b; padding: 24px; text-align: center; max-width: 300px;">
                        <div style="font-size: 24px; margin-bottom: 12px;">❌ Connection Error</div>
                        <div style="font-size: 13px; color: #aaa; margin-bottom: 16px; line-height: 1.5;">${error.message}</div>
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button onclick="location.reload()" class="btn" style="width: auto;">
                                🔄 Retry
                            </button>
                            <button onclick="loadDemo()" class="btn" style="width: auto; background: var(--accent-color); color: #000;">
                                🧪 Load Demo Data
                            </button>
                        </div>
                    </div>
                `;
            }
        }

        // Expose load function for buttons
        window.loadDemo = () => {
            // Reset loading html to spinner
            loading.innerHTML = '<div class="spinner"></div><div class="loading-text">Generating Demo Data...</div>';
            loadData(true);
        };

        function updateStats() {
            document.getElementById('topicCount').textContent = allData.topics.length;
            document.getElementById('bigramCount').textContent = allData.bigrams.length;
            document.getElementById('paperCount').textContent = allData.papers.length;
        }

        // Generate Bigram Network Structure (Hub + Spoke)
        function computeBigramLinks() {
            allData.bigramLinks = [];
            const bigramsByTopic = {};

            // Group by topic
            allData.bigrams.forEach(b => {
                if (!bigramsByTopic[b.topic_id]) bigramsByTopic[b.topic_id] = [];
                bigramsByTopic[b.topic_id].push(b);
            });

            // Create connections for each topic cluster
            Object.values(bigramsByTopic).forEach(group => {
                if (group.length < 2) return;

                // Sort by frequency (highest is Hub)
                group.sort((a, b) => (b.normalized_frequency || 0) - (a.normalized_frequency || 0));
                const hub = group[0];

                // Connect all others to the Hub
                for (let i = 1; i < group.length; i++) {
                    const spoke = group[i];
                    allData.bigramLinks.push({
                        source: spoke,
                        target: hub,
                        color: hub.color
                    });
                }
            });
            console.log(`🕸️ Generated ${allData.bigramLinks.length} bigram network connections`);
        }

        let simulation;

        function initMacroView() {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.45;

            // 1. Position Topics (Keep strict Right Arc)
            // 1. Position Topics
            updateTopicPositions();

            // 2. Prepare Bigrams (Physics nodes - larger)
            allData.bigrams.forEach(b => {
                b.radius = b.radius || 15;
                // Initial random positions near center
                b.x = centerX + (Math.random() - 0.5) * 200;
                b.y = centerY + (Math.random() - 0.5) * 200;
            });

            // 3. Prepare Papers (Physics nodes - dust)
            allData.papers.forEach(p => {
                p.radius = 2; // Small dust particles
                // Initial random positions
                p.x = centerX + (Math.random() - 0.5) * 500;
                p.y = centerY + (Math.random() - 0.5) * 500;
            });

            // 4. Build Links (Paper -> Bigram)
            const physicsLinks = [];
            allData.papers.forEach(p => {
                if (p.bigramIds && p.bigramIds.length > 0) {
                    p.bigramIds.forEach(bid => {
                        const target = allData.bigrams.find(b => b.id === bid);
                        if (target) {
                            physicsLinks.push({
                                source: p,
                                target: target,
                                strength: 0.1
                            });
                        }
                    });
                }
            });

            // 5. Initialize D3 Simulation
            if (simulation) simulation.stop();

            simulation = d3.forceSimulation([...allData.bigrams, ...allData.papers])
                .force("link", d3.forceLink(physicsLinks).distance(80).strength(0.02)) // Loose attraction
                .force("charge", d3.forceManyBody().strength(d => {
                    return d.type === 'bigram' ? -300 : -1; // Bigrams repel strongly, papers minimal
                }))
                // Use slightly larger collision radius to account for new sizes
                .force("collide", d3.forceCollide().radius(d => d.type === 'bigram' ? d.radius + 5 : 2.5).iterations(2))
                .force("center", d3.forceCenter(centerX * 0.8, centerY).strength(0.05)) // Shift center left slightly to balance topics
                .force("radial", d3.forceRadial(radius * 0.5, centerX * 0.8, centerY).strength(0.01))
                .alphaDecay(0.01); // Slower decay for continuous movement
        }

        // Check if two nodes are connected
        function isConnected(node1, node2) {
            if (!node1 || !node2) return false;

            // Same node
            if (node1.id === node2.id && node1.type === node2.type) return true;

            // Check topic connections
            if (node1.type === 'topic' && node2.type === 'bigram') {
                return node2.topic_id === node1.id;
            }
            if (node1.type === 'bigram' && node2.type === 'topic') {
                return node1.topic_id === node2.id;
            }
            if (node1.type === 'topic' && node2.type === 'paper') {
                return node2.topicId === node1.id;
            }
            if (node1.type === 'paper' && node2.type === 'topic') {
                return node1.topicId === node2.id;
            }
            if (node1.type === 'bigram' && node2.type === 'paper') {
                return node2.topicId === node1.topic_id;
            }
            if (node1.type === 'paper' && node2.type === 'bigram') {
                return node1.topicId === node2.topic_id;
            }

            return false;
        }

        // Cached tokens for performance
        let cachedSearchTerm = null;
        let cachedTokens = [];

        // Check if node matches search (Enhanced)
        function matchesSearch(node) {
            if (!searchTerm || !searchTerm.trim()) return true;

            // Update cache if input changed
            if (searchTerm !== cachedSearchTerm) {
                cachedSearchTerm = searchTerm;
                cachedTokens = searchTerm.toLowerCase()
                    .replace(/[.,;()]/g, ' ') // Strip punctuation
                    .split(/\s+/)             // Tokenize by whitespace
                    .filter(t => t.length > 0);
            }

            if (cachedTokens.length === 0) return true;

            // Match against ANY token (OR logic)
            const matchAny = (text) => {
                if (!text) return false;
                const lower = text.toLowerCase();
                return cachedTokens.some(token => lower.includes(token));
            };

            if (node.type === 'topic') {
                return matchAny(node.topic_name);
            }
            if (node.type === 'bigram') {
                return matchAny(node.bigram);
            }
            if (node.type === 'paper') {
                return matchAny(node.title) ||
                    matchAny(node.authors) ||
                    matchAny(node.journal);
            }
            return false;
        }

        // Draw connections for selected node
        function drawConnections(centerX, centerY) {
            if (!selectedNode) return;

            ctx.lineWidth = 1;

            if (selectedNode.type === 'topic') {
                // Draw topic's bigrams and papers
                const topicBigrams = allData.bigrams.filter(b => b.topic_id === selectedNode.id);

                // IF Bigram View, ONLY draw bigrams (to topic center)
                if (currentView === 'bigram_network') {
                    topicBigrams.forEach(bigram => {
                        ctx.strokeStyle = selectedNode.color;
                        ctx.beginPath();
                        ctx.moveTo(selectedNode.x, selectedNode.y);
                        ctx.lineTo(bigram.x, bigram.y);
                        ctx.stroke();
                    });
                    return;
                }

                const topicPapers = allData.papers.filter(p => p.topicId === selectedNode.id && p.year <= maxYear);

                // For each paper, draw its ACTUAL bigram connections
                topicPapers.forEach(paper => {
                    const paperBigrams = topicBigrams.filter(b => paper.bigramIds.includes(b.id));

                    if (paperBigrams.length === 0) {
                        paperBigrams.push(...topicBigrams.slice(0, 2));
                    }

                    paperBigrams.forEach(bigram => {
                        ctx.strokeStyle = paper.color;
                        ctx.beginPath();
                        ctx.moveTo(bigram.x, bigram.y);
                        ctx.lineTo(paper.x, paper.y);
                        ctx.stroke();
                    });

                    // Papers to topic
                    ctx.strokeStyle = selectedNode.color;
                    ctx.beginPath();
                    ctx.moveTo(paper.x, paper.y);
                    ctx.lineTo(selectedNode.x, selectedNode.y);
                    ctx.stroke();
                });

            } else if (selectedNode.type === 'bigram') {
                // IF Bigram View, show connections to same-topic bigrams (via topic center)
                if (currentView === 'bigram_network') {
                    // Connect to its topic
                    const topic = allData.topics.find(t => t.id === selectedNode.topic_id);
                    if (topic) {
                        ctx.strokeStyle = topic.color;
                        ctx.beginPath();
                        ctx.moveTo(selectedNode.x, selectedNode.y);
                        ctx.lineTo(topic.x, topic.y);
                        ctx.stroke();
                    }
                    return;
                }

                // standard macro logic
                const connectedPapers = allData.papers.filter(p =>
                    p.bigramIds.includes(selectedNode.id) && p.year <= maxYear
                );

                if (connectedPapers.length === 0) {
                    // Fallback: show papers from same topic
                    connectedPapers.push(
                        ...allData.papers.filter(p => p.topicId === selectedNode.topic_id && p.year <= maxYear).slice(0, 50)
                    );
                }

                const topic = allData.topics.find(t => t.id === selectedNode.topic_id);

                connectedPapers.forEach(paper => {
                    ctx.strokeStyle = selectedNode.color;
                    ctx.beginPath();
                    ctx.moveTo(selectedNode.x, selectedNode.y);
                    ctx.lineTo(paper.x, paper.y);
                    ctx.stroke();

                    if (topic) {
                        ctx.strokeStyle = topic.color;
                        ctx.beginPath();
                        ctx.moveTo(paper.x, paper.y);
                        ctx.lineTo(topic.x, topic.y);
                        ctx.stroke();
                    }
                });

            } else if (selectedNode.type === 'paper') {
                // Draw paper's ACTUAL bigram connections
                const topic = allData.topics.find(t => t.id === selectedNode.topicId);
                const paperBigrams = allData.bigrams.filter(b => selectedNode.bigramIds.includes(b.id));

                if (paperBigrams.length === 0) {
                    paperBigrams.push(...allData.bigrams.filter(b => b.topic_id === selectedNode.topicId).slice(0, 2));
                }

                paperBigrams.forEach(bigram => {
                    ctx.strokeStyle = selectedNode.color;
                    ctx.beginPath();
                    ctx.moveTo(bigram.x, bigram.y);
                    ctx.lineTo(selectedNode.x, selectedNode.y);
                    ctx.stroke();
                });

                if (topic) {
                    ctx.strokeStyle = topic.color;
                    ctx.beginPath();
                    ctx.moveTo(selectedNode.x, selectedNode.y);
                    ctx.lineTo(topic.x, topic.y);
                    ctx.stroke();
                }
            }
        }

        function drawMacroView() {
            // Clear entire canvas (in screen coordinates)
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, width, height);
            ctx.restore();

            const centerX = width / 2;
            const centerY = height / 2;

            ctx.save();
            // Apply Zoom/Pan Transform
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.k, transform.k);

            // ONLY draw connections if something is selected
            if (selectedNode) {
                ctx.globalAlpha = 0.4;
                drawConnections(centerX, centerY);
                ctx.globalAlpha = 1.0;
            }

            // --- DRAW LAYERS (Ordered) ---

            // TOPIC MODE FILTER: Identify valid IDs
            let validTopicId = null;
            let validBigramIds = new Set();




            // 1. Bigram Connections (if Toggle ON)
            if (showBigramNetwork && allData.bigramLinks) {
                ctx.globalAlpha = 0.6; // Higher opacity
                ctx.lineWidth = 3.5; // Significantly thicker lines


                // Draw calculated bigram-bigram connections
                allData.bigramLinks.forEach(link => {


                    ctx.beginPath();
                    ctx.strokeStyle = link.color;
                    ctx.moveTo(link.source.x, link.source.y);
                    ctx.lineTo(link.target.x, link.target.y);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1.0;
            }

            // 2. Papers (Always Visible OR filtered by new Bigram-Paper View)
            allData.papers.forEach(paper => {


                const paperYear = paper.year || 2024;
                // Filter: Year Range
                if (paperYear < minYear || paperYear > maxYear) return;
                // Filter: Journal
                if (!selectedJournals.has(paper.journal || 'Unknown')) return;

                // New Bigram-Paper Visibility Logic
                let alpha = 1.0;
                let scale = 1.0;
                let isRelevant = true;

                if (showBigramPaperConnections) {
                    // In this mode, only show papers connected to bigrams
                    if (!paper.bigramIds || paper.bigramIds.length === 0) {
                        isRelevant = false;
                        alpha = 0.02; // Ghostly
                    }
                }




                if (showBigramPaperConnections && isRelevant) {
                    // Draw lines to connected bigrams
                    paper.bigramIds.forEach(bid => {
                        const bigram = allData.bigrams.find(b => b.id === bid);
                        if (bigram) {
                            ctx.beginPath();
                            ctx.strokeStyle = bigram.color;
                            ctx.globalAlpha = 0.15; // Subtle connection
                            ctx.lineWidth = 0.5;
                            ctx.moveTo(paper.x, paper.y);
                            ctx.lineTo(bigram.x, bigram.y);
                            ctx.stroke();
                            ctx.globalAlpha = alpha; // Reset
                        }
                    });
                }

                const isMatch = matchesSearch(paper);

                // Visual Guidance: "Light Field" effect
                // If search is active:
                // - Matches: Full opacity, slightly larger scale?
                // - Non-matches: Faded but visible (ghosted)

                if (cachedTokens.length > 0) {
                    if (isMatch) {
                        alpha = 1.0;
                        scale = 1.2; // Slight highlighting match
                    } else {
                        alpha = selectedNode ? 0.05 : 0.1; // Faded
                        scale = 0.5;
                    }
                } else {
                    // Standard logic when no search
                    if (!isMatch) {
                        alpha = 0.05;
                        scale = 0.5;
                        isRelevant = false;
                    } else if (selectedNode && !isConnected(paper, selectedNode)) {
                        alpha = 0.1;
                        scale = 0.8;
                        isRelevant = false;
                    }
                }

                if (showBigramPaperConnections && isRelevant) {
                    // Draw lines to connected bigrams
                    paper.bigramIds.forEach(bid => {
                        const bigram = allData.bigrams.find(b => b.id === bid);
                        if (bigram) {
                            ctx.beginPath();
                            ctx.strokeStyle = bigram.color;
                            ctx.globalAlpha = isMatch ? 0.3 : 0.05; // Highlight connections if paper matches
                            ctx.lineWidth = isMatch ? 1.0 : 0.5;
                            ctx.moveTo(paper.x, paper.y);
                            ctx.lineTo(bigram.x, bigram.y);
                            ctx.stroke();
                            ctx.globalAlpha = alpha; // Reset
                        }
                    });
                }

                // Optimization: Skip barely visible dots if not part of active view or search
                if (alpha < 0.05 && !isMatch) return;

                ctx.globalAlpha = alpha;
                ctx.fillStyle = paper.color;

                // Draw as small rectangles for performance if needed, or circles
                // Circles look better for "dust"
                ctx.beginPath();
                ctx.arc(paper.x, paper.y, paper.radius * scale, 0, Math.PI * 2);
                ctx.fill();
            });


            // Draw bigrams (planets)
            allData.bigrams.forEach(bigram => {
                let alpha = 1.0;

                const isMatch = matchesSearch(bigram);
                if (!isMatch) {
                    alpha = 0.1;
                } else if (selectedNode && !isConnected(bigram, selectedNode)) {
                    alpha = 0.2; // Keep bigrams slightly more visible than papers
                }

                ctx.globalAlpha = alpha;

                // Glow
                const gradient = ctx.createRadialGradient(
                    bigram.x, bigram.y, 0,
                    bigram.x, bigram.y, bigram.radius * 2
                );
                gradient.addColorStop(0, bigram.color);
                gradient.addColorStop(0.5, bigram.color + '60');
                gradient.addColorStop(1, bigram.color + '00');

                ctx.beginPath();
                ctx.arc(bigram.x, bigram.y, bigram.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Solid center
                ctx.beginPath();
                ctx.arc(bigram.x, bigram.y, bigram.radius * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = bigram.color;
                ctx.fill();

                ctx.globalAlpha = 1.0;
            });

            // Draw topics (Fixed anchors) - VISUALLY SUPPRESSED PER USER REQUEST
            // But in Topic Mode, we might want to ensure the central anchor is visible? 
            // Currently user request says "VISUALLY SUPPRESSED" generally, but let's respect that globally.
            // If the user previously suppressed them, we keep them suppressed or very faint unless logic changes.
            // The previous code block for topics is commented out (lines 1421-1452 in original snippet), so they are invisible.
            // We will leave them strictly as is.
            allData.topics.forEach(topic => {
                // Topic Mode Filter (If we were drawing them)
                if (validTopicId && topic.id !== validTopicId) return;

                /* 
                let alpha = 1.0;
                const isMatch = matchesSearch(topic);
 
                if (!isMatch) {
                    alpha = 0.1;
                }
 
                ctx.globalAlpha = alpha;
 
                // Glow
                const gradient = ctx.createRadialGradient(
                    topic.x, topic.y, 0,
                    topic.x, topic.y, topic.radius * 3
                );
                gradient.addColorStop(0, topic.color);
                gradient.addColorStop(0.3, topic.color + '60');
                gradient.addColorStop(1, topic.color + '00');
 
                ctx.beginPath();
                ctx.arc(topic.x, topic.y, topic.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
 
                // Solid center
                ctx.beginPath();
                ctx.arc(topic.x, topic.y, topic.radius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = topic.color;
                ctx.fill();
 
                ctx.globalAlpha = 1.0;
                */
            });


            // Bigram labels (only if matching search or zoomed/relevant)
            ctx.font = 'bold 14px Inter, sans-serif';
            allData.bigrams.forEach((bigram, i) => {
                // Show label if searched OR if node is large/important OR if just general exploration (some sampling)
                // With physics, bigrams move.
                if (!matchesSearch(bigram)) return;

                // Show all bigram labels? might be cluttered. 125 bigrams.
                // Let's show them.

                let alpha = 1.0;
                if (activeSpotlights.size > 0) {
                    // Check if bigram is connected to ANY active spotlight node
                    let linked = false;
                    for (let spot of activeSpotlights) {
                        if (isConnected(bigram, spot)) { linked = true; break; }
                    }
                    if (!linked) alpha = 0.1;
                }
                else if (selectedNode && !isConnected(bigram, selectedNode)) alpha = 0.1;

                ctx.globalAlpha = alpha;
                ctx.globalAlpha = alpha;

                // Text Color Logic: Check for Light Mode
                if (document.body.classList.contains('theme-light')) {
                    ctx.fillStyle = '#222'; // Dark text for light background
                } else {
                    ctx.fillStyle = '#ddd'; // Light text for dark background
                }

                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                // FULL UNTRUNCATED LABEL
                ctx.fillText(bigram.bigram, bigram.x, bigram.y - bigram.radius - 2);
                ctx.globalAlpha = 1.0;
            });

            ctx.restore();
        }

        function drawPulse(ctx, node) {
            if (!node) return;

            // Continuous pulse animation based on time
            const time = Date.now();
            const period = 2000;
            const progress = (time % period) / period;
            const alpha = 1 - progress;

            ctx.save();
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.k, transform.k);

            // Expanding ring
            const radius = 10 + (progress * 40);

            ctx.beginPath();
            ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(78, 205, 196, ${alpha})`;
            ctx.lineWidth = 2 / transform.k;
            ctx.stroke();

            // Inner core halo
            ctx.beginPath();
            ctx.arc(node.x, node.y, 8 / transform.k, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(78, 205, 196, 0.4)`;
            ctx.fill();

            ctx.restore();
        }

        function animate() {
            if (currentView === 'macro') {
                drawMacroView();
                if (activeSpotlights.size > 0) {
                    activeSpotlights.forEach(node => drawPulse(ctx, node));
                }
            }
            animationFrame = requestAnimationFrame(animate);
        }

        // Helper to hide tooltip strictly
        function hideTooltip() {
            tooltip.classList.remove('visible');
        }

        // Event listeners
        let selectedTopicId = null;
        const topicSelect = document.getElementById('topicSelect');

        topicSelect.addEventListener('change', (e) => {
            const value = e.target.value;
            if (value === 'all') {
                // Macro view logic
                if (urlState.mode === 'topic') {
                    window.location.href = 'index.html';
                }
            } else {
                // Enforce Number type
                const tId = Number(value);
                console.log(`Selected Topic ID: ${tId}`);

                if (!Number.isNaN(tId) && tId > 0) {
                    if (urlState.mode === 'topic') {
                        // Switch Topic (Same Tab)
                        window.location.href = `index.html?mode=topic&topicId=${tId}`;
                    } else {
                        // Open Topic (New Tab) - Keep Macro View intact
                        window.open(`index.html?mode=topic&topicId=${tId}`, '_blank');
                        // Reset dropdown to 'all' only in Macro view (to keep context clear)
                        topicSelect.value = 'all';
                    }
                } else {
                    console.error('Invalid Topic ID selected:', value);
                }
            }
        });



        const yearStartInput = document.getElementById('yearSliderStart');
        const yearEndInput = document.getElementById('yearSliderEnd');
        const rangeProgress = document.getElementById('rangeProgress');
        const yearValueDisplay = document.getElementById('yearValue');

        function updateYearRange() {
            let start = parseInt(yearStartInput.value);
            let end = parseInt(yearEndInput.value);

            if (start > end) {
                const tmp = start;
                start = end;
                end = tmp;
            }

            minYear = start;
            maxYear = end;

            yearValueDisplay.textContent = `${minYear} – ${maxYear}`;

            // Update Progress Bar
            const total = 2024 - 1980;
            const leftPercent = ((minYear - 1980) / total) * 100;
            const widthPercent = ((maxYear - minYear) / total) * 100;

            rangeProgress.style.left = `${leftPercent}%`;
            rangeProgress.style.width = `${widthPercent}%`;

            // Update Stats
            const visiblePapers = allData.papers.filter(p => {
                const y = p.year || 2024;
                return y >= minYear && y <= maxYear;
            }).length;
            document.getElementById('paperCount').textContent = visiblePapers;
        }

        yearStartInput.addEventListener('input', updateYearRange);
        yearEndInput.addEventListener('input', updateYearRange);

        // Search Listener
        document.getElementById('searchInput').addEventListener('input', (e) => {
            searchTerm = e.target.value; // Store raw value
            // Logic handles trimming/tokenizing in matchesSearch

            // Update feedback UI immediately
            const tokens = searchTerm.toLowerCase().replace(/[.,;()]/g, ' ').split(/\s+/).filter(t => t.length > 0);
            const feedbackEl = document.getElementById('searchFeedback');
            if (tokens.length > 0) {
                feedbackEl.textContent = `Active keywords: ${tokens.join(' · ')}`;
            } else {
                feedbackEl.textContent = '';
            }
        });

        // Reset Listener
        document.getElementById('bigramPaperToggle').addEventListener('change', (e) => {
            showBigramPaperConnections = e.target.checked;
            // If this is on, we might want to ensure Bigram Network is on? No, prompt says independent.
            // But Prompt says "All bigram nodes (125) are visible."
            // Bigrams are always visible in drawMacroView unless filtered?
            // Let's ensure a redraw
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            searchTerm = '';
            const searchInp = document.getElementById('searchInput');
            if (searchInp) searchInp.value = '';
            const searchFeed = document.getElementById('searchFeedback');
            if (searchFeed) searchFeed.textContent = '';

            selectedNode = null;
            minYear = 1980;
            maxYear = 2024;

            const ysStart = document.getElementById('yearSliderStart');
            if (ysStart) ysStart.value = 1980;
            const ysEnd = document.getElementById('yearSliderEnd');
            if (ysEnd) ysEnd.value = 2024;

            if (typeof updateYearRange === 'function') updateYearRange();

            const yVal = document.getElementById('yearValue');
            if (yVal) yVal.textContent = '1980 – 2024';

            const tSelect = document.getElementById('topicSelect');
            if (tSelect) tSelect.value = 'all';

            // Reset Zoom
            if (canvas && zoom) {
                d3.select(canvas).transition().duration(750)
                    .call(zoom.transform, d3.zoomIdentity);
            }

            if (typeof initMacroView === 'function') initMacroView(); // Reset positions
            console.log('🔄 View Reset');
        });

        // Zoom Controls (Main)
        document.getElementById('zoomIn').addEventListener('click', () => {
            d3.select(canvas).transition().call(zoom.scaleBy, 1.3);
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            d3.select(canvas).transition().call(zoom.scaleBy, 0.7);
        });

        // Zoom Controls (Sidebar Duplicates)
        const sidebarZoomIn = document.getElementById('sidebarZoomIn');
        const sidebarZoomOut = document.getElementById('sidebarZoomOut');

        if (sidebarZoomIn) {
            sidebarZoomIn.addEventListener('click', () => {
                d3.select(canvas).transition().call(zoom.scaleBy, 1.3);
            });
        }

        if (sidebarZoomOut) {
            sidebarZoomOut.addEventListener('click', () => {
                d3.select(canvas).transition().call(zoom.scaleBy, 0.7);
            });
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Apply Inverse Transform
            const mouseX = (e.clientX - rect.left - transform.x) / transform.k;
            const mouseY = (e.clientY - rect.top - transform.y) / transform.k;

            let hoveredNode = null;

            /*
            for (let topic of allData.topics) {
                const dx = mouseX - topic.x;
                const dy = mouseY - topic.y;
                if (Math.sqrt(dx * dx + dy * dy) < topic.radius + 8) {
                    hoveredNode = topic;
                    break;
                }
            }
            */

            if (!hoveredNode) {
                for (let bigram of allData.bigrams) {
                    const dx = mouseX - bigram.x;
                    const dy = mouseY - bigram.y;
                    if (Math.sqrt(dx * dx + dy * dy) < bigram.radius + 5) {
                        hoveredNode = bigram;
                        break;
                    }
                }
            }

            if (!hoveredNode) {
                for (let paper of allData.papers) {
                    const dx = mouseX - paper.x;
                    const dy = mouseY - paper.y;
                    if (Math.sqrt(dx * dx + dy * dy) < paper.radius + 3) {
                        hoveredNode = paper;
                        break;
                    }
                }
            }

            if (hoveredNode) {
                canvas.style.cursor = 'pointer';
                tooltip.classList.add('visible');
                // Tooltip position remains in SCREEN coordinates
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';

                // Re-use tooltip content logic from Macro View
                if (hoveredNode.type === 'topic') {
                    tooltip.innerHTML = `
                            <div class="tooltip-header" style="color:${hoveredNode.color}">${hoveredNode.name}</div>
                            <div class="tooltip-sub">Topic ID: ${hoveredNode.id}</div>
                        `;
                } else if (hoveredNode.type === 'bigram') {
                    // Check for extra metadata if available, otherwise just Name/Freq
                    const freq = hoveredNode.frequency_sum || hoveredNode.weight || 'N/A';
                    tooltip.innerHTML = `
                            <div class="tooltip-header" style="color:var(--accent-color)">${hoveredNode.bigram}</div>
                            <div class="tooltip-sub">Occurrences: ${freq}</div>
                        `;
                } else if (hoveredNode.type === 'paper') {
                    // Safe author formatting - supports both String (new) and Array (legacy) formats
                    let authorsShort = hoveredNode.authors;
                    if (!authorsShort) {
                        authorsShort = '(missing)';
                    } else if (Array.isArray(authorsShort)) {
                        // Handle legacy array format if present
                        if (authorsShort.length > 2) {
                            authorsShort = (authorsShort[0].last_name || authorsShort[0].name || 'Unknown') + ' et al.';
                        } else {
                            authorsShort = authorsShort.map(a => a.last_name || a.name || 'Unknown').join(' & ');
                        }
                    }
                    // If string, use directly (dataset default)

                    tooltip.innerHTML = `
                        <div style="margin-bottom: 4px;">
                             <span class="tooltip-tag" style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px;">${hoveredNode.year || 'N/A'}</span>
                        </div>
                        <div class="tooltip-title" style="margin-bottom: 12px; font-size: 14px; font-weight: 700; color: #fff; line-height: 1.3;">${hoveredNode.title || 'Untitled Paper'}</div>
                        
                        <div style="width: 100%; height: 1px; background: rgba(255,255,255,0.15); margin-bottom: 12px;"></div>

                        <div class="tooltip-meta" style="margin-bottom: 6px; font-size: 12px; line-height: 1.4;">
                             <span style="color: #888;">Authors:</span> <span style="color: #ddd;">${authorsShort}</span>
                        </div>
                        <div class="tooltip-meta" style="font-size: 12px; line-height: 1.4;">
                             <span style="color: #888;">Journal:</span> <span style="color: var(--accent-color);">${hoveredNode.journal || 'N/A'}</span>
                        </div>
                    `;
                }
            } else {
                canvas.style.cursor = 'default';
                hideTooltip();
            }
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Apply Inverse Transform
            const mouseX = (e.clientX - rect.left - transform.x) / transform.k;
            const mouseY = (e.clientY - rect.top - transform.y) / transform.k;

            let clickedNode = null;

            // Check topics
            for (let topic of allData.topics) {
                const dx = mouseX - topic.x;
                const dy = mouseY - topic.y;
                if (Math.sqrt(dx * dx + dy * dy) < topic.radius + 8) {
                    clickedNode = topic;
                    break;
                }
            }

            // Check bigrams
            if (!clickedNode) {
                for (let bigram of allData.bigrams) {
                    const dx = mouseX - bigram.x;
                    const dy = mouseY - bigram.y;
                    if (Math.sqrt(dx * dx + dy * dy) < bigram.radius + 5) {
                        clickedNode = bigram;
                        break;
                    }
                }
            }

            // Check papers
            if (!clickedNode) {
                for (let paper of allData.papers) {
                    const dx = mouseX - paper.x;
                    const dy = mouseY - paper.y;
                    if (Math.sqrt(dx * dx + dy * dy) < paper.radius + 3) {
                        clickedNode = paper;
                        break;
                    }
                }
            }

            if (clickedNode) {
                selectedNode = clickedNode;
                console.log(`✨ Selected ${clickedNode.type}:`, clickedNode);
            } else {
                // Click on empty space - reset
                selectedNode = null;
                hideTooltip(); // Explicitly hide tooltip
                console.log('🔄 Reset selection');
            }
        });

        // Mouseout listener to clear tooltip when leaving canvas
        canvas.addEventListener('mouseout', () => {
            hideTooltip();
        });

        window.addEventListener('resize', () => {
            if (urlState.mode === 'topic') {
                // Constrain to topic container
                const container = document.getElementById('topic-network-container');
                if (container) {
                    const rect = container.getBoundingClientRect();
                    width = rect.width;
                    height = rect.height;
                    canvas.width = width;
                    canvas.height = height;
                    initMacroView(); // Restart sim
                    return;
                }
            }

            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if (allData.topics.length > 0) {
                initMacroView();
            }
        });

        // Toggle Listener
        const bigramToggle = document.getElementById('bigramToggle');
        if (bigramToggle) {
            bigramToggle.addEventListener('change', (e) => {
                showBigramNetwork = e.target.checked;
            });
        }

        // Ring View Toggle
        const ringToggle = document.getElementById('ringViewToggle');
        if (ringToggle) {
            ringToggle.addEventListener('change', (e) => {
                isRingView = e.target.checked;
                updateTopicPositions();
                console.log('🔄 Topic Layout Updated:', isRingView ? 'Ring View' : 'Arc View');
            });
        }

        function updateTopicPositions() {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.45;

            if (isRingView) {
                // Full Circle Ring
                const step = (Math.PI * 2) / Math.max(1, allData.topics.length);
                // Start from -PI/2 (top)
                const startAngle = -Math.PI / 2;

                allData.topics.forEach((topic, i) => {
                    const angle = startAngle + i * step;
                    topic.x = centerX + radius * Math.cos(angle);
                    topic.y = centerY + radius * Math.sin(angle);
                    topic.radius = 12;
                });
            } else {
                // Default Right Arc
                const topicArcStart = -Math.PI / 2.2;
                const topicArcEnd = Math.PI / 2.2;
                const topicStep = (topicArcEnd - topicArcStart) / Math.max(1, allData.topics.length - 1);

                allData.topics.forEach((topic, i) => {
                    const angle = topicArcStart + i * topicStep;
                    // Position: CenterX * 1.5 pushes it to the right side
                    topic.x = centerX * 1.5 + radius * Math.cos(angle) * 0.8;
                    topic.y = centerY + radius * Math.sin(angle);
                    topic.radius = 12;
                });
            }
        }



        // Theme Toggle Listener
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
            if (document.body.classList.contains('theme-light')) {
                themeToggle.checked = false;
            } else {
                themeToggle.checked = true;
            }

            themeToggle.addEventListener('change', (e) => {
                if (!e.target.checked) {
                    document.body.classList.add('theme-light');
                    updateStatus('Switched to Light Mode');
                } else {
                    document.body.classList.remove('theme-light');
                    updateStatus('Switched to Dark Mode');
                }
            });
        }

        // --- NEW: UI Logic for Tabs & Advanced Search ---

        function switchTab(tab) {
            // Update Tabs UI
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'transparent';
                btn.style.color = '#888';
            });

            const activeBtn = document.getElementById(`tab-${tab}`);
            activeBtn.classList.add('active');
            activeBtn.style.background = 'rgba(255,255,255,0.1)';
            activeBtn.style.color = '#fff';

            // Show Content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(`content-${tab}`);
            activeContent.style.display = 'flex'; // 'flex' for search, 'block' for browse?
            // Actually search uses flex for layout, browse uses block components.
            // Let's reset purely based on ID
            if (tab === 'search') {
                activeContent.style.display = 'flex';
                // Initialize adv filters if needed (once)
                /* logic moved to populateAdvancedFilters */
            } else {
                activeContent.style.display = 'block';
            }
        }

        function toggleJournalDropdown() {
            const content = document.getElementById('journalDropdownContent');
            const isVisible = content.style.display === 'block';
            content.style.display = isVisible ? 'none' : 'block';

            // Rotate arrow?
            // Optional polish
        }

        // Close dropdown if clicked outside
        document.addEventListener('click', (e) => {
            const btn = document.getElementById('journalDropdownBtn');
            const content = document.getElementById('journalDropdownContent');
            if (btn && content && !btn.contains(e.target) && !content.contains(e.target)) {
                content.style.display = 'none';
            }
        });

        function toggleRefine() {
            const content = document.getElementById('refineContent');
            const icon = document.getElementById('refineToggleIcon');
            const isVisible = content.style.display === 'block';
            content.style.display = isVisible ? 'none' : 'block';
            icon.textContent = isVisible ? '+' : '−';
        }

        // --- Advanced Search Logic ---

        function populateAdvancedFilters() {
            console.log('⚙️ Populating Advanced Search Filters...');

            // 1. Topics
            const advTopicSelect = document.getElementById('advTopicSelect');
            if (advTopicSelect && allData.topics.length > 0) {
                advTopicSelect.innerHTML = '<option value="all">All Topics</option>';
                allData.topics.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t.id;
                    opt.textContent = `Topic ${t.id}: ${t.topic_name}`;
                    advTopicSelect.appendChild(opt);
                });

                // Add listener
                advTopicSelect.addEventListener('change', performAdvancedSearch);
            }

            // 2. Journals (Interactive Filter for Refine)
            const advJournalList = document.getElementById('advJournalList');
            if (advJournalList && allData.papers.length > 0) {
                advJournalList.innerHTML = '';
                const uniqueJournals = [...new Set(allData.papers.map(p => p.journal || 'Unknown'))].sort();

                uniqueJournals.forEach(j => {
                    const div = document.createElement('div');
                    div.style.cssText = "display: flex; gap: 6px; align-items: center; margin-bottom: 4px; color: #ccc;";
                    div.innerHTML = `
                            <input type="checkbox" id="adv-j-${j.replace(/\s+/g, '')}" value="${j}" checked style="accent-color: var(--accent-color);">
                            <label for="adv-j-${j.replace(/\s+/g, '')}" style="margin:0; cursor:pointer; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${j}</label>
                        `;
                    // Listener
                    div.querySelector('input').addEventListener('change', performAdvancedSearch);
                    advJournalList.appendChild(div);
                });
            }
            // 2b. Main Search Controls (Input, Scope, Match Type)
            const advSearchInput = document.getElementById('advSearchInput');
            if (advSearchInput) {
                advSearchInput.addEventListener('input', performAdvancedSearch);

                // Tag Creation Listener
                advSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ',') {
                        e.preventDefault();
                        const val = advSearchInput.value.trim().replace(/,/g, '');
                        if (val) {
                            searchTags.push(val);
                            advSearchInput.value = '';
                            renderTags();
                            performAdvancedSearch();
                        }
                    } else if (e.key === 'Backspace' && !advSearchInput.value && searchTags.length > 0) {
                        // Helper to remove last tag on backspace if clean
                        searchTags.pop();
                        renderTags();
                        performAdvancedSearch();
                    }
                });
            }

            const advSearchScope = document.getElementById('advSearchScope');
            if (advSearchScope) advSearchScope.addEventListener('change', performAdvancedSearch);

            document.querySelectorAll('input[name="matchType"]').forEach(rb => {
                rb.addEventListener('change', performAdvancedSearch);
            });

            // 3. Timeframe listeners
            document.getElementById('advYearSliderStart').addEventListener('input', (e) => {
                // Sync specific UI for Adv slider if we want visual feedback numbers? 
                // For now just perform search
                performAdvancedSearch();
            });
            document.getElementById('advYearSliderEnd').addEventListener('input', performAdvancedSearch);

            // 4. Manual Toggle
            const manualToggle = document.getElementById('navGuideToggle');
            if (manualToggle) {
                manualToggle.addEventListener('change', (e) => {
                    // Show/Hide overlay
                    matchManualOverlay(e.target.checked);
                });
            }
        }

        function matchManualOverlay(show) {
            let overlay = document.getElementById('manualOverlay');
            if (!overlay) {
                // Create it on fly with strict modal structure
                overlay = document.createElement('div');
                overlay.id = 'manualOverlay';
                overlay.style.cssText = "position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 999; display: none; align-items: center; justify-content: center;";

                // Allow closing by clicking backdrop
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        document.getElementById('navGuideToggle').checked = false;
                        matchManualOverlay(false);
                    }
                };

                overlay.innerHTML = `
                        <div style="position: relative; background: var(--glass-bg); backdrop-filter: blur(20px); border: 1px solid var(--glass-border); padding: 40px; border-radius: 16px; max-width: 500px; color: #fff; font-family: Inter, sans-serif; box-shadow: 0 20px 50px rgba(0,0,0,0.5);">
                            <button id="closeOverlayBtn" style="position: absolute; top: 16px; right: 16px; background: transparent; border: none; color: #fff; font-size: 24px; cursor: pointer; opacity: 0.7;">&times;</button>
                            
                            <div style="margin-bottom: 30px;">
                                <div style="font-size: 14px; font-weight: 700; color: var(--accent-color); margin-bottom: 4px;">1. Choose your lens</div>
                                <div style="font-size: 13px; color: #ccc; line-height: 1.5;">Select specific topics to isolate the network. The macro view shows the entire landscape.</div>
                                <div style="width: 50px; height: 1px; background: rgba(255,255,255,0.2); margin-top: 12px;"></div>
                            </div>
                            <div style="margin-bottom: 30px;">
                                <div style="font-size: 14px; font-weight: 700; color: var(--accent-color); margin-bottom: 4px;">2. Define scope</div>
                                <div style="font-size: 13px; color: #ccc; line-height: 1.5;">Slide the timeframe to filter papers by year. Watch patterns emerge and fade over time.</div>
                            </div>
                            <div>
                                <div style="font-size: 14px; font-weight: 700; color: var(--accent-color); margin-bottom: 4px;">3. Search</div>
                                <div style="font-size: 13px; color: #ccc; line-height: 1.5;">Use Advanced Search for targeted discovery of papers, authors, or concepts.</div>
                            </div>
                        </div>
                    `;
                document.body.appendChild(overlay);

                // X Button
                document.getElementById('closeOverlayBtn').onclick = () => {
                    document.getElementById('navGuideToggle').checked = false;
                    matchManualOverlay(false);
                };

                // ESC key listener
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && overlay.style.display === 'flex') {
                        document.getElementById('navGuideToggle').checked = false;
                        matchManualOverlay(false);
                    }
                });
            }
            overlay.style.display = show ? 'flex' : 'none';
        }

        // Radar Pulse / Spotlight State
        let activeSpotlights = new Set(); // Persistent highlight nodes (Set)
        let searchTags = []; // Array of string tags

        function renderTags() {
            const container = document.getElementById('advSearchTags');
            if (!container) return;
            container.innerHTML = '';
            searchTags.forEach((tag, idx) => {
                const chip = document.createElement('div');
                chip.style.cssText = "display: flex; align-items: center; gap: 4px; background: var(--accent-color); color: #000; padding: 2px 6px; border-radius: 4px; font-size: 11px; font-weight: 600;";
                chip.innerHTML = `<span>${tag}</span><span style="cursor: pointer; opacity: 0.6; font-size: 10px;">✕</span>`;
                chip.querySelector('span:last-child').onclick = (e) => {
                    e.stopPropagation();
                    searchTags.splice(idx, 1);
                    renderTags();
                    performAdvancedSearch();
                };
                container.appendChild(chip);
            });
        }

        function performAdvancedSearch() {
            // GUARDS: Restore Search Functionality
            if (!allData || !allData.papers) {
                console.warn('⚠️ Search interrupted: Data not ready.');
                return;
            }
            const searchInput = document.getElementById('advSearchInput');
            if (!searchInput) return;

            // Handle Input Text
            let query = searchInput.value.trim().toLowerCase();

            // If Tags exist, they become the primary source. Query is supplemental if present.
            const hasTags = searchTags.length > 0;

            // Only clear if empty
            if (!query && !hasTags) {
                const resultsList = document.getElementById('searchResultsList');
                const countLabel = document.getElementById('searchResultsCount');
                if (resultsList) resultsList.innerHTML = '';
                if (countLabel) countLabel.textContent = 'Enter search term';
                return;
            }

            const scope = document.getElementById('advSearchScope').value;
            const matchType = document.querySelector('input[name="matchType"]:checked').value;
            const resultsList = document.getElementById('searchResultsList');
            const countLabel = document.getElementById('searchResultsCount');

            // Refine constraints
            const startEl = document.getElementById('advYearSliderStart');
            const endEl = document.getElementById('advYearSliderEnd');
            let startYear = startEl ? parseInt(startEl.value) : 1980;
            let endYear = endEl ? parseInt(endEl.value) : 2024;

            // Fix swapped years logic (prevents 0 results when ranges cross)
            if (startYear > endYear) {
                const temp = startYear;
                startYear = endYear;
                endYear = temp;
            }

            // Update Visual Progress Bar for Advanced Search
            const advRangeProgress = document.getElementById('advRangeProgress');
            if (advRangeProgress) {
                const total = 2024 - 1980;
                const leftPercent = ((startYear - 1980) / total) * 100;
                const widthPercent = ((endYear - startYear) / total) * 100;
                advRangeProgress.style.left = `${leftPercent}%`;
                advRangeProgress.style.width = `${widthPercent}%`;
            }

            const topicSelectEl = document.getElementById('advTopicSelect');
            const topicConstraint = topicSelectEl ? topicSelectEl.value : 'all'; // 'all' or ID

            // Get selected journals in Refine
            const selectedAdvJournals = new Set();
            const journalInputs = document.querySelectorAll('#advJournalList input');
            let ignoreJournalFilter = false;

            if (journalInputs.length === 0) {
                ignoreJournalFilter = true;
            } else {
                document.querySelectorAll('#advJournalList input:checked').forEach(cb => selectedAdvJournals.add(cb.value));
            }

            // Helper: Check constraints
            const checkConstraints = (item) => {
                // Type-specific checks
                if (item.type === 'paper') {
                    // Logic: Keep if WITHIN range
                    if (item.year < startYear || item.year > endYear) return false;
                    if (!ignoreJournalFilter && !selectedAdvJournals.has(item.journal || 'Unknown')) return false;
                    if (topicConstraint !== 'all' && item.topicId != topicConstraint) return false;
                }
                else if (item.type === 'bigram') {
                    if (topicConstraint !== 'all' && item.topic_id != topicConstraint) return false;
                }
                else if (item.type === 'topic') {
                    if (topicConstraint !== 'all' && item.id != topicConstraint) return false;
                }
                return true;
            };

            // Helper: Match Text Against Query OR Tags
            const checkMatch = (text) => {
                if (!text) return false;
                const clean = text.toLowerCase();

                // 1. Check current input query
                let matchInput = false;
                if (query) {
                    if (matchType === 'exact') matchInput = (clean === query);
                    else matchInput = clean.includes(query);
                }
                if (matchInput) return true;

                // 2. Check Tags (OR Logic)
                if (hasTags) {
                    return searchTags.some(tag => {
                        const t = tag.toLowerCase();
                        if (matchType === 'exact') return clean === t;
                        return clean.includes(t);
                    });
                }

                return false;
            };

            let results = [];

            // 1. Search Topics
            if (scope === 'all' || scope === 'topic') {
                allData.topics.forEach(t => {
                    if (!checkConstraints(t)) return;
                    if (checkMatch(t.topic_name)) results.push(t);
                });
            }

            // 2. Search Bigrams (Terms)
            if (scope === 'all' || scope === 'term') {
                allData.bigrams.forEach(b => {
                    if (!checkConstraints(b)) return;
                    if (checkMatch(b.bigram)) results.push(b);
                });
            }

            // 3. Search Papers (Title, Author, Journal)
            // Limit to 100 to avoid freezing
            let paperCount = 0;
            for (let p of allData.papers) {
                if (paperCount > 100) break;
                if (!checkConstraints(p)) continue;

                // Optimization: Check quick match first
                let match = false;
                if (scope === 'all') {
                    match = checkMatch(p.title) || checkMatch(p.authors) || checkMatch(p.journal);
                } else if (scope === 'paper') {
                    match = checkMatch(p.title);
                } else if (scope === 'author') {
                    match = checkMatch(p.authors);
                } else if (scope === 'journal') {
                    match = checkMatch(p.journal);
                }

                if (match) {
                    results.push(p);
                    paperCount++;
                }
            }

            // Render Results
            const countText = results.length === 0 ? 'No matching results found' : `${results.length}${results.length > 100 ? '+' : ''} results`;
            countLabel.innerHTML = `<span>${countText}</span>`;

            // Restore Clear Highlight Button if active spotlights exist
            if (activeSpotlights.size > 0 && results.length > 0) { // Changed condition
                countLabel.innerHTML += `
                        <span id="clearHighlightBtn" style="float: right; cursor: pointer; color: var(--accent-color); font-weight: bold; font-size: 10px; border: 1px solid var(--accent-color); padding: 2px 6px; border-radius: 4px;">× Clear selection</span>
                     `;
                setTimeout(() => {
                    const btn = document.getElementById('clearHighlightBtn');
                    if (btn) {
                        btn.onclick = (e) => {
                            e.stopPropagation();
                            activeSpotlights.clear(); // Clear all
                            selectedNode = null;
                            performAdvancedSearch(); // Re-render header to remove button and list highlight
                        };
                    }
                }, 0);
            }

            resultsList.innerHTML = '';
            if (results.length === 0) return;

            results.slice(0, 100).forEach(item => {
                const row = document.createElement('div');
                row.className = 'result-row'; // Marker class

                // Dynamic styling based on selection
                const isSelected = activeSpotlights.has(item);
                const baseBg = isSelected ? 'rgba(78, 205, 196, 0.2)' : 'rgba(255,255,255,0.05)';
                const baseBorder = isSelected ? 'var(--accent-color)' : 'transparent';

                row.style.cssText = `padding: 8px; background: ${baseBg}; border-radius: 4px; cursor: pointer; border: 1px solid ${baseBorder}; transition: all 0.1s; margin-bottom: 6px;`;

                row.onmouseover = () => {
                    if (!activeSpotlights.has(item)) {
                        row.style.borderColor = 'var(--accent-color)';
                        row.style.background = 'rgba(255,255,255,0.1)';
                    }
                };
                row.onmouseout = () => {
                    if (!activeSpotlights.has(item)) {
                        row.style.borderColor = 'transparent';
                        row.style.background = 'rgba(255,255,255,0.05)';
                    }
                };

                let label = '';
                let sub = '';
                let tag = item.type.toUpperCase();
                let tagColor = '#888';

                if (item.type === 'topic') {
                    label = item.topic_name;
                    sub = `Topic ${item.id}`;
                    tagColor = item.color;
                } else if (item.type === 'bigram') {
                    label = item.bigram;
                    sub = `Term in Topic ${item.topic_id}`;
                    tagColor = item.color;
                } else if (item.type === 'paper') {
                    label = item.title;
                    sub = `${item.year} · ${item.authors ? item.authors.substring(0, 20) + '...' : 'Unknown'}`;
                    tagColor = '#fff';
                }

                row.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 2px;">
                            <span style="font-size: 9px; font-weight: 700; background: rgba(255,255,255,0.1); padding: 2px 4px; border-radius: 2px; color: ${tagColor}">${tag}</span>
                            <span style="font-size: 9px; color: #666;">➔</span>
                        </div>
                        <div style="font-size: 11px; font-weight: 600; color: #ddd; line-height: 1.3; margin-bottom: 2px;">${label}</div>
                        <div style="font-size: 10px; color: #888;">${sub}</div>
                    `;

                row.onclick = () => {
                    console.log('Result clicked:', item);
                    selectedNode = item; // Still update last selected for certain logic

                    // 1. TOPIC: Switch View (Keep behavior)
                    if (item.type === 'topic') {
                        const sel = document.getElementById('topicSelect');
                        if (sel) {
                            sel.value = item.id;
                            sel.dispatchEvent(new Event('change'));
                        }
                        switchTab('browse');
                        return;
                    }

                    // 2. PAPER & TERM: Toggle Selection & Persistent Spotlight
                    if (item.type === 'paper') {
                        const paperToggle = document.getElementById('bigramPaperToggle');
                        if (paperToggle && !paperToggle.checked) {
                            if (countLabel) countLabel.innerHTML = '<span style="color:#ff6b6b">⚠️ Enable "Terms linked to papers" to locate this paper.</span>';
                            return;
                        }
                    }

                    // Toggle Logic
                    if (activeSpotlights.has(item)) {
                        activeSpotlights.delete(item);
                        // Visual update handled by re-render below or manual style update?
                        // Re-running search is safest to update all row styles and header count
                    } else {
                        activeSpotlights.add(item);
                        initiateFlyTo(item); // Only fly to newly added
                    }

                    performAdvancedSearch(); // Refresh UI State
                };

                resultsList.appendChild(row);
            });
        }

        // Radar Fly-To Logic
        function initiateFlyTo(targetNode) {
            if (!targetNode || !targetNode.x) return;

            // 1. Calculate target transform to center the node
            // Zoom level: 2.5x is a good "sensible level"
            const targetScale = 2.5;
            const targetX = width / 2 - targetNode.x * targetScale;
            const targetY = height / 2 - targetNode.y * targetScale;

            // 2. Animate Camera (d3.zoom)
            const svgCanvas = d3.select(canvas); // We use d3 zoom on the canvas element context

            svgCanvas.transition()
                .duration(1200)
                .call(zoom.transform, d3.zoomIdentity.translate(targetX, targetY).scale(targetScale))
                .on("end", () => {
                    // 3. Trigger Persistent Spotlight
                    activeSpotlights.add(targetNode);
                });
        }

        // Hook into existing animate loop for pulse
        const originalDraw = window.draw || function () { }; // fallback


        // Start!
        // Start!
        // Moved to end of file to ensure all functions are defined
        // loadData().then(() => { populateAdvancedFilters(); });

        // Override loadDemo to ensure filters populate
        window.loadDemo = () => {
            const loadingToUse = document.getElementById('loading') || document.querySelector('.loading-text')?.parentNode;
            if (loadingToUse) loadingToUse.innerHTML = '<div class="spinner"></div><div class="loading-text">Generating Demo Data...</div>';
            loadData(true).then(() => {
                populateAdvancedFilters();
            });
        };

        // Expose reload for error screen
        window.location.reload = () => {
            window.location.href = window.location.href; // Force reload
        };

        // --- TEMPORAL VIEW LOGIC ---
        let temporalDataLoaded = false;

        // NOTE: We use SUPABASE_URL and SUPABASE_KEY defined globally in this file.
        // We do NOT assume 'supabase' client object exists, as this app uses direct fetch helper.

        async function loadTemporalView() {
            if (temporalDataLoaded) return;

            const chartDiv = document.getElementById('topic-prevalence-chart');
            if (!chartDiv) return;

            chartDiv.innerHTML = '<div style="text-align:center; padding:100px; color:var(--text-secondary); font-style:italic;">Loading temporal data...</div>';

            // Check environment variables
            if (typeof SUPABASE_URL === 'undefined' || typeof SUPABASE_KEY === 'undefined') {
                chartDiv.innerHTML = '<div style="color:red; text-align:center; padding:50px;">Supabase configuration missing (SUPABASE_URL/KEY).</div>';
                return;
            }

            try {
                const viewName = 'v_topic_prevalence_top8_other_by_year_v3';
                const select = 'year,series_key,series_rank,series_name,papers_count,series_color';
                const order = 'year.asc';

                const url = `${SUPABASE_URL}/rest/v1/${viewName}?select=${select}&order=${order}`;
                console.log('Fetching Temporal URL:', url);

                const response = await fetch(url, {
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=representation'
                    }
                });

                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errText}`);
                }

                const data = await response.json();
                if (data && data.length > 0) console.log('First Temporal Row:', data[0]);

                if (!data || data.length === 0) {
                    chartDiv.innerHTML = '<div style="text-align:center; padding:100px; color:var(--text-secondary);">No data returned for the selected timeframe.</div>';
                    return;
                }

                window.temporalData = data; // Store globally for modal
                renderTemporalChart(data);
                fetchAndRenderCorpusGrowth(); // Uses v_corpus_growth_by_year_v1
                fetchAndRenderEmergence();    // Uses v_topic_trend_10y_share_change_v1
                fetchAndRenderTopicTrends();  // Uses v_chart4_topic_trends
                temporalDataLoaded = true;

                // Init Tooltip if missing
                if (d3.select('#temporal-tooltip').empty()) {
                    d3.select('body').append('div').attr('id', 'temporal-tooltip')
                        .style('position', 'absolute').style('background', 'var(--l-sidebar-bg)')
                        .style('border', '1px solid var(--l-border)').style('padding', '6px 10px')
                        .style('border-radius', '4px').style('pointer-events', 'none')
                        .style('font-size', '11px').style('color', 'var(--text-primary)')
                        .style('opacity', 0).style('z-index', 9999).style('box-shadow', '0 4px 12px rgba(0,0,0,0.2)');
                }

            } catch (e) {
                console.error('Topic Prevalence Load Error:', e);
                chartDiv.innerHTML = `<div style="color:red; text-align:center; padding:50px;">Error loading topic prevalence: ${e.message}</div>`;
            }

            // Load other charts independently
            fetchAndRenderCorpusGrowth(); // Now uses papers table directly
            // fetchAndRenderEmergence();    // Skipped for now
            // fetchAndRenderTopicTrends();  // Skipped for now
            temporalDataLoaded = true;
        }

        async function fetchAndRenderCorpusGrowth() {
            const container = document.getElementById('corpus-growth-chart');
            if (!container) return;
            container.innerHTML = '<div style="color:var(--text-secondary); font-size:12px;">Loading...</div>';

            try {
                // Wait for global data load (allData.papers)
                let attempts = 0;
                const maxAttempts = 100; // Allow up to 20s

                // Helper to check state
                const checkReady = () => {
                    const dataObj = (typeof allData !== 'undefined') ? allData : window.allData;
                    const hasData = !!dataObj;
                    const hasArray = hasData && Array.isArray(dataObj.papers);
                    const length = hasArray ? dataObj.papers.length : 0;
                    return { ready: hasData && hasArray && length > 0, hasData, hasArray, length, dataObj };
                };

                while (attempts < maxAttempts) {
                    const status = checkReady();

                    if (attempts === 0) {
                        console.log('Corpus Growth wait: starting', {
                            hasAllData: status.hasData,
                            hasPapersArray: status.hasArray,
                            papersLength: status.length
                        });

                        if (!status.ready) {
                            container.innerHTML = '<div style="color:var(--text-secondary); font-size:12px;">Waiting for data...</div>';
                        }
                    }

                    if (status.ready) break;

                    await new Promise(r => setTimeout(r, 200));
                    attempts++;
                }

                const finalStatus = checkReady();

                if (!finalStatus.ready) {
                    console.warn('Corpus Growth wait: timeout', {
                        hasAllData: finalStatus.hasData,
                        hasPapersArray: finalStatus.hasArray,
                        papersLength: finalStatus.length
                    });
                    container.innerHTML = '<div style="color:var(--text-secondary); font-size:12px;">Data not available.</div>';
                    return;
                }

                console.log(`Corpus Growth wait: ready (${finalStatus.length} papers)`);
                const papers = finalStatus.dataObj.papers;

                // 3. Aggregate (Distinct IDs)
                const yearCounts = {};
                const seenIds = new Set();
                let missingYearCount = 0;

                // Initialize range (1980-2025)
                const yStart = (typeof minYear !== 'undefined') ? minYear : 1980;
                const yEnd = (typeof maxYear !== 'undefined') ? maxYear : 2025;

                for (let y = 1980; y <= 2025; y++) {
                    yearCounts[y] = 0;
                }

                papers.forEach(p => {
                    const y = parseInt(p.year);
                    // Use id or paper_id depending on what's available in the cached object
                    const pid = p.id || p.paper_id;

                    if (isNaN(y)) {
                        missingYearCount++;
                        return;
                    }

                    // Strict Deduplication by ID
                    if (pid && !seenIds.has(pid)) {
                        seenIds.add(pid);

                        // Apply Filters (Timeframe & Journal)
                        if (y >= 1980 && y <= 2025) {
                            if (y >= yStart && y <= yEnd) {
                                // Check Journal Filter
                                let include = true;
                                if (typeof selectedJournals !== 'undefined' && selectedJournals.size > 0) {
                                    include = selectedJournals.has(p.journal);
                                }

                                if (include) {
                                    yearCounts[y] = (yearCounts[y] || 0) + 1;
                                }
                            }
                        }
                    }
                });

                let fullData = Object.keys(yearCounts).sort().map(y => ({
                    year: parseInt(y),
                    count: yearCounts[y]
                }));

                // FIX: Trim trailing years that have no data to prevent chart "drop-off" to zero
                // Find the last year with data
                let maxYearInSeries = 0;
                let minYearInSeries = 2025;

                fullData.forEach(d => {
                    if (d.count > 0) {
                        if (d.year > maxYearInSeries) maxYearInSeries = d.year;
                        if (d.year < minYearInSeries) minYearInSeries = d.year;
                    }
                });

                // Filter out years beyond the max year found in data
                // This ensures we don't plot 2025 as 0 if data ends in 2024
                if (maxYearInSeries > 0) {
                    fullData = fullData.filter(d => d.year <= maxYearInSeries);
                }

                // Verification Logs
                console.group('Corpus Growth Fix Verification');
                console.log('minYearInSeries:', minYearInSeries);
                console.log('maxYearInSeries:', maxYearInSeries);
                console.log('lastPoint:', fullData[fullData.length - 1]);
                console.groupEnd();

                // --- Corpus Growth Integrity Check ---
                console.group('Corpus Growth Integrity Check');
                const distinctSourceIds = new Set();
                const invalidYearIds = [];
                papers.forEach(p => {
                    const pid = p.id || p.paper_id;
                    if (pid) distinctSourceIds.add(pid);
                    if (isNaN(parseInt(p.year))) invalidYearIds.push(pid);
                });
                const X = distinctSourceIds.size;
                const Y = fullData.reduce((sum, d) => sum + d.count, 0);
                const Z = X - Y;

                console.log(`Total papers in source (distinct by paper_id if available): ${X}`);
                console.log(`Sum of yearly counts: ${Y}`);
                console.log(`Difference (X - Y): ${Z}`);

                if (Z !== 0) {
                    console.warn('Discrepancy detected:');
                    console.log(`number of papers with missing/invalid year: ${invalidYearIds.length}`);
                    if (invalidYearIds.length > 0) {
                        console.log(`sample of up to 10 paper_id (or id) values with missing year:`, invalidYearIds.slice(0, 10));
                    }
                }
                console.groupEnd();
                // -------------------------------------

                // 4. Audit Logs (Updated for Cached Data)
                const totalPlotted = fullData.reduce((sum, d) => sum + d.count, 0);
                const distinctPaperCount = seenIds.size;
                const maxYearCount = Math.max(0, ...fullData.map(d => d.count));

                console.group('Corpus Growth Audit (Fixed)');
                console.log(`1. Source: allData.papers (Cached)`);
                console.log(`2. Total Cached Rows: ${papers.length}`);
                console.log(`3. Total Distinct Papers (by ID): ${distinctPaperCount}`);
                console.log(`4. Sum of Plotted Counts: ${totalPlotted}`);
                console.log(`5. Rows with Missing Year: ${missingYearCount}`);

                // New: Yearly Counts Preview
                console.log('6. Yearly Counts Preview (First 10):', fullData.slice(0, 10));
                console.log('7. Yearly Counts Preview (Last 10):', fullData.slice(-10));

                // New: Validation Checks
                const isJournalFilterActive = (typeof selectedJournals !== 'undefined' && selectedJournals.size > 0);
                const isFullTimeframe = (yStart <= 1981 && yEnd >= 2023);

                if (!isJournalFilterActive && isFullTimeframe) {
                    if (distinctPaperCount < 1000) {
                        console.error('%cWARNING: Corpus Growth is not reading the full corpus. Check if allData.papers is fully populated.', 'color: red; font-weight: bold; font-size: 14px;');
                    }
                }
                console.groupEnd();
                // ----------------------------------

                renderCorpusChartD3(container, fullData);

            } catch (e) {
                console.error('Corpus Growth Error:', e);
                container.innerHTML = '<div style="color:var(--text-secondary); font-style:italic; padding:20px; text-align:center;">Unable to load corpus growth data.<br>(' + e.message + ')</div>';
            }
        }

        function renderCorpusChartD3(container, data) {
            container.innerHTML = '';
            const width = container.clientWidth;
            const height = 200;
            const margin = { top: 20, right: 20, bottom: 40, left: 50 };

            const svg = d3.select(container).append('svg')
                .attr('width', width).attr('height', height).style('overflow', 'visible');

            // Dynamic domain based on data or globals
            const xDomain = d3.extent(data, d => d.year);
            const x = d3.scaleLinear().domain(xDomain).range([margin.left, width - margin.right]);
            const y = d3.scaleLinear().domain([0, d3.max(data, d => d.count)]).range([height - margin.bottom, margin.top]);

            // Area
            const area = d3.area()
                .x(d => x(d.year))
                .y0(y(0))
                .y1(d => y(d.count))
                .curve(d3.curveMonotoneX);

            svg.append('path')
                .datum(data)
                .attr('fill', 'var(--accent-color)')
                .attr('fill-opacity', 0.2)
                .attr('d', area);

            // Line
            const line = d3.line()
                .x(d => x(d.year))
                .y(d => y(d.count))
                .curve(d3.curveMonotoneX);

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', 'var(--accent-color)')
                .attr('stroke-width', 2)
                .attr('d', line);

            // Interactive Overlay (Rects for tooltip)
            const overlayWidth = (width - margin.left - margin.right) / (2025 - 1980 + 1);

            svg.selectAll('.hover-rect')
                .data(data)
                .join('rect')
                .attr('class', 'hover-rect')
                .attr('x', d => x(d.year) - overlayWidth / 2)
                .attr('y', margin.top)
                .attr('width', overlayWidth)
                .attr('height', height - margin.top - margin.bottom)
                .attr('fill', 'transparent')
                .on('mouseover', function (event, d) {
                    d3.select(this).attr('fill', 'rgba(255,255,255,0.05)');
                    const tt = d3.select('#temporal-tooltip');
                    tt.style('opacity', 1).html(`Year: ${d.year}<br>Papers: ${d.count}`)
                        .style('left', (event.pageX + 10) + 'px').style('top', (event.pageY - 20) + 'px');
                })
                .on('mouseout', function () {
                    d3.select(this).attr('fill', 'transparent');
                    d3.select('#temporal-tooltip').style('opacity', 0);
                });

            const xAxis = d3.axisBottom(x).tickFormat(d3.format('d')).tickValues(d3.range(1980, 2026, 5));
            const yAxis = d3.axisLeft(y).ticks(5);

            svg.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(xAxis).selectAll('text').attr('fill', 'var(--text-secondary)').style('font-family', 'Inter').style('font-size', '10px');
            svg.append('g').attr('transform', `translate(${margin.left},0)`).call(yAxis).selectAll('text').attr('fill', 'var(--text-secondary)').style('font-family', 'Inter').style('font-size', '10px');
            svg.selectAll('.domain, .tick line').attr('stroke', 'var(--text-secondary)').attr('opacity', 0.2);

            // Labels
            svg.append('text').attr('x', width / 2).attr('y', height).attr('fill', 'var(--text-secondary)').style('font-size', '10px').style('text-anchor', 'middle').text('Year');
            svg.append('text').attr('transform', 'rotate(-90)').attr('x', -height / 2).attr('y', 15).attr('fill', 'var(--text-secondary)').style('font-size', '10px').style('text-anchor', 'middle').text('Papers');
        }

        async function fetchAndRenderEmergence() {
            const container = document.getElementById('emerging-declining-container');
            if (!container) return;
            container.innerHTML = '<div style="color:var(--text-secondary); font-size:12px;">Loading trends...</div>';
            try {
                // Use V2 with corrected 1980-89 vs 2016-25 timeframe
                // URL: Request ONLY existing columns (direction, topic_id, topic_name, share_change_pp, first_decade_share, last_decade_share)
                // Does NOT request 'series_color' as it is not in the view.
                const url = `${SUPABASE_URL}/rest/v1/v_topic_trends_10yr_v2?select=direction,topic_id,topic_name,share_change_pp,first_decade_share,last_decade_share&limit=100`;
                console.log('Fetching Chart 3 URL:', url);

                const response = await fetch(url, { headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` } });

                if (!response.ok) {
                    const errBody = await response.text();
                    console.error('Emergence Fetch Failed:', response.status, errBody);
                    throw new Error(`HTTP ${response.status}: ${errBody}`);
                }

                const data = await response.json();

                if (data && data.length > 0) {
                    console.log('Chart 3 Data Sample:', data[0]);
                } else {
                    console.warn('Chart 3 Data is empty');
                }

                renderEmergenceTables(data);
            } catch (e) {
                console.warn('Emergence Error:', e);
                container.innerHTML = `<div style="color:var(--text-secondary); font-style:italic; padding:20px; text-align:center;">
                        Trend data unavailable.<br>
                        <span style="font-size:10px; opacity:0.7;">${e.message}</span>
                    </div>`;
            }
        }

        function renderEmergenceTables(data) {
            const container = document.getElementById('emerging-declining-container');
            if (!container) return;

            // Clear any inline background on the main container to avoid double-boxing
            container.style.background = 'transparent';

            // Ensure numeric fields are parsed safely
            data.forEach(d => {
                d.share_change_pp = parseFloat(d.share_change_pp) || 0;
                d.first_decade_share = parseFloat(d.first_decade_share) || 0;
                d.last_decade_share = parseFloat(d.last_decade_share) || 0;
            });

            // Sort by magnitude of change (descending)
            data.sort((a, b) => Math.abs(b.share_change_pp) - Math.abs(a.share_change_pp));

            const rising = data.filter(d => d.direction === 'rising').slice(0, 10);
            const declining = data.filter(d => d.direction === 'declining').slice(0, 10);

            function makeTable(title, rows, isRising) {
                // Surface styling for contrast
                // Using var(--chart-panel-bg) gives a solid card look (Light surface in Light, Darker in Dark)
                // Adding a border for definition
                const surfaceStyle = `
                        flex:1; 
                        min-width:320px; 
                        padding: 20px; 
                        background: var(--chart-panel-bg); 
                        border: 1px solid var(--chart-panel-border); 
                        border-radius: 12px;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.03);
                    `;

                let html = `<div style="${surfaceStyle}">
                        <div style="font-size:13px; font-weight:800; margin-bottom:6px; color:var(--text-primary); text-transform:uppercase; letter-spacing:1px; display:flex; align-items:center; gap:8px;">
                            ${isRising ? '<span style="color:#4ECDC4">▲</span>' : '<span style="color:#FF6B6B">▼</span>'} ${title}
                        </div>
                        <div style="font-size:11px; color:var(--text-secondary); margin-bottom:16px; border-bottom:1px solid var(--chart-row-border); padding-bottom:12px; font-weight:500;">
                            Top 10 by share change (1980s vs 2020s)
                        </div>
                        <table style="width:100%; border-collapse:collapse; font-size:13px; background: transparent;">
                            <thead>
                                <tr style="color:var(--text-secondary); text-align:left; border-bottom:1px solid var(--chart-row-border);">
                                    <th style="padding:8px 4px; font-weight:700; font-size:10px; text-transform:uppercase; letter-spacing:0.05em; opacity:0.8;">Topic</th>
                                    <th style="padding:8px 4px; text-align:right; font-weight:700; font-size:10px; text-transform:uppercase; letter-spacing:0.05em; width:96px; opacity:0.8;">Change</th>
                                </tr>
                            </thead>
                            <tbody>`;

                rows.forEach(r => {
                    const val = r.share_change_pp > 0 ? '+' + r.share_change_pp.toFixed(1) : r.share_change_pp.toFixed(1);
                    const col = isRising ? '#4ECDC4' : '#FF6B6B';
                    const rowColor = r.series_color || '#999';

                    // Naming convention: Topic <id>: <name>
                    const displayName = `Topic ${r.topic_id}: ${r.topic_name}`;

                    // Escape single quotes (safely)
                    const safeDisplayName = displayName.replace(/'/g, "&apos;");

                    // Tooltip
                    const tooltipText = `<strong>${safeDisplayName}</strong><br>1980s share: ${r.first_decade_share.toFixed(1)}%<br>Latest share: ${r.last_decade_share.toFixed(1)}%<br>Change: ${val}pp`;

                    html += `<tr style="border-bottom:1px solid var(--chart-row-border); cursor:default; transition: all 0.2s;" 
                                     onmouseover="const tt=document.getElementById('temporal-tooltip'); tt.style.opacity=1; tt.innerHTML='${tooltipText}'; tt.style.left=(event.pageX+10)+'px'; tt.style.top=(event.pageY-20)+'px'; this.style.background='var(--chart-row-hover)';" 
                                     onmouseout="document.getElementById('temporal-tooltip').style.opacity=0; this.style.background='transparent';">
                            <td style="padding:8px 4px; display:flex; align-items:center; gap:8px;">
                                <div style="width:6px; height:6px; border-radius:50%; background:${rowColor}; flex-shrink:0;"></div>
                                <span style="color:var(--text-primary); font-weight:500; font-variant-numeric: tabular-nums; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:220px;">${displayName}</span>
                            </td>
                            <td style="padding:8px 4px; text-align:right; color:${col}; font-weight:600; font-variant-numeric: tabular-nums; width:96px;">${val}pp</td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
                return html;
            }

            container.style.display = 'flex';
            container.style.flexWrap = 'wrap';
            // Increase gap to accommodate the card look
            container.style.gap = '24px';
            container.style.justifyContent = 'space-between';
            container.style.alignItems = 'flex-start';

            container.innerHTML = '';

            // Rising Panel
            container.innerHTML += makeTable('Rising', rising, true);

            // Declining Panel
            container.innerHTML += makeTable('Declining', declining, false);
        }

        function renderTemporalChart(data, containerId = 'topic-prevalence-chart', legendId = 'topic-prevalence-legend', customHeight = null) {
            const container = document.getElementById(containerId);
            const legendContainer = legendId ? document.getElementById(legendId) : null;
            if (!container || !data) return;

            container.innerHTML = '';
            if (legendContainer) legendContainer.innerHTML = '';

            // 1. Process Metadata (Rank, Color, Name) per Series
            const seriesMeta = {};
            data.forEach(d => {
                if (!seriesMeta[d.series_key]) {
                    seriesMeta[d.series_key] = {
                        rank: d.series_rank,
                        name: d.series_name,
                        color: d.series_color
                    };
                }
            });

            const seriesKeys = Object.keys(seriesMeta);
            // Sort keys by rank DESC (99, 8... 1) so Stack builds correctly (99 at bottom)
            // Stack layers: keys[0] is bottom-most.
            seriesKeys.sort((a, b) => seriesMeta[b].rank - seriesMeta[a].rank);

            // 2. Pivot & Gap Fill (Trim to actual data presence)

            // Re-calculate last year with active data (>0 papers)
            const activeData = data.filter(d => Boolean(d.papers_count) && d.papers_count > 0);

            const minYearInData = d3.min(activeData, d => d.year) || 1980;
            const maxYearInDataRaw = d3.max(data, d => d.year) || 2025;
            const lastYearWithData = d3.max(activeData, d => d.year) || maxYearInDataRaw;

            console.group('Chart2 Trim Audit');
            console.log(`minYearInData: ${minYearInData}`);
            console.log(`maxYearInDataRaw: ${maxYearInDataRaw}`);
            console.log(`lastYearWithData: ${lastYearWithData}`);
            console.log(`Any year > lastYearWithData with counts > 0?`, activeData.some(d => d.year > lastYearWithData));
            console.groupEnd();

            const years = [];

            // Generate years based on requested range [minYearInData, lastYearWithData]
            // Note: If you want to force 1980 start, use 1980. But user requested [minYearInData, lastYearWithData].
            // However, to be safe and consistent with previous request, I'll use minYearInData unless it is way too late (e.g. 2000).
            // Let's stick to minYearInData as requested.

            const startY = minYearInData;
            const endY = lastYearWithData;

            for (let y = startY; y <= endY; y++) years.push(y);

            const dataset = years.map(y => {
                const row = { year: y };
                seriesKeys.forEach(k => { row[k] = 0; }); // Initialize with 0

                // Fill from data
                data.filter(d => d.year === y).forEach(d => {
                    row[d.series_key] = d.papers_count;
                });

                // Add total for tooltip
                row.total = seriesKeys.reduce((acc, k) => acc + row[k], 0);
                return row;
            });

            // FIX: Add End-Cap Year to prevent visual "drop to zero"
            // We duplicate the last real year's data into a new year (lastYear + 1)
            const endcapYear = lastYearWithData + 1;
            const lastRow = dataset[dataset.length - 1];

            if (lastRow) {
                const endcapRow = { ...lastRow, year: endcapYear };
                dataset.push(endcapRow);
                years.push(endcapYear); // Update years array for scale domain
            }

            console.group('Chart2 Endcap Audit');
            console.log(`minYearInData: ${minYearInData}`);
            console.log(`lastYearWithData: ${lastYearWithData}`);
            console.log(`endcapYear: ${endcapYear}`);
            console.log(`Endcap Applied?`, dataset[dataset.length - 1].year === endcapYear);
            console.groupEnd();

            // 3. D3 Setup
            const width = container.clientWidth;
            // If customHeight is 'flex', use clientHeight (for modal)
            const height = customHeight === 'flex' ? container.clientHeight : (customHeight || 400);
            const margin = { top: 20, right: 20, bottom: 40, left: 50 };

            // Safety check for zero height
            if (height <= 0) return;

            const svg = d3.select(container).append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', `0 0 ${width} ${height}`)
                .style('overflow', 'visible');

            const x = d3.scaleLinear()
                .domain(d3.extent(years))
                .range([margin.left, width - margin.right]);

            const stack = d3.stack()
                .keys(seriesKeys)
                .order(d3.stackOrderNone)
                .offset(d3.stackOffsetNone);

            const series = stack(dataset);

            const yMax = d3.max(series, s => d3.max(s, d => d[1]));
            const y = d3.scaleLinear()
                .domain([0, yMax])
                .range([height - margin.bottom, margin.top]);

            const area = d3.area()
                .x(d => x(d.data.year))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]))
                .curve(d3.curveMonotoneX);

            // Draw Areas
            svg.append('g')
                .selectAll('path')
                .data(series)
                .join('path')
                .attr('fill', d => seriesMeta[d.key].color)
                .attr('d', area)
                .attr('opacity', 0.85)
                .attr('stroke', '#fff')
                .attr('stroke-width', 0.5)
                .attr('stroke-opacity', 0.2)
                .on('mouseover', function (event, d) {
                    d3.select(this).attr('opacity', 1).attr('stroke', '#fff').attr('stroke-width', 1).attr('stroke-opacity', 0.8);
                    const pt = d3.pointer(event, this);
                    const xVal = x.invert(pt[0]);
                    const year = Math.round(xVal);

                    // Find series value
                    const row = dataset.find(r => r.year === year);
                    const val = row ? row[d.key] : 0;

                    d3.select('#temporal-tooltip').style('opacity', 1)
                        .html(`<strong>${seriesMeta[d.key].name}</strong><br>Year: ${year}<br>Papers: ${val}`)
                        .style('left', (event.pageX + 10) + 'px').style('top', (event.pageY - 20) + 'px');
                })
                .on('mouseout', function (event, d) {
                    d3.select(this).attr('opacity', 0.85).attr('stroke', '#fff').attr('stroke-width', 0.5).attr('stroke-opacity', 0.2);
                    d3.select('#temporal-tooltip').style('opacity', 0);
                });

            // Axes
            const xAxis = d3.axisBottom(x).tickFormat(d3.format('d')).tickValues(d3.range(1980, 2026, 5));
            const yAxis = d3.axisLeft(y).ticks(5);

            svg.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(xAxis);
            svg.append('g').attr('transform', `translate(${margin.left},0)`).call(yAxis);

            // Labels
            svg.append('text').attr('x', width / 2).attr('y', height).attr('fill', 'var(--text-secondary)').style('font-size', '10px').style('text-anchor', 'middle').text('Year');
            svg.append('text').attr('transform', 'rotate(-90)').attr('x', -height / 2).attr('y', 15).attr('fill', 'var(--text-secondary)').style('font-size', '10px').style('text-anchor', 'middle').text('Number of papers (Top 8 + Other)');

            // Style Axes
            svg.selectAll('.domain, .tick line').attr('stroke', 'var(--text-secondary)').attr('opacity', 0.3);
            svg.selectAll('.tick text').attr('fill', 'var(--text-secondary)').style('font-family', 'Inter').style('font-size', '10px');

            // 4. Legend (Only if container provided)
            if (legendContainer) {
                // Display in reverse order (1, 2... 8, 99)
                seriesKeys.slice().reverse().forEach(key => {
                    const meta = seriesMeta[key];
                    const item = document.createElement('div');
                    item.style.cssText = 'display:flex; align-items:center; gap:6px; font-size:11px; color:var(--text-secondary);';
                    item.innerHTML = `<div style="width:12px; height:12px; background:${meta.color}; border-radius:2px;"></div><span>${meta.name}</span>`;
                    legendContainer.appendChild(item);
                });
            }
        }

        // Chart 4: Topic Trends (Spaghetti)
        async function fetchAndRenderTopicTrends() {
            const container = document.getElementById('topic-trends-chart');
            const legend = document.getElementById('topic-trends-legend');
            if (!container) return;

            try {
                // FIX: Pagination loop to fetch all rows beyond PostgREST 1000-row default limit
                let allRows = [];
                let offset = 0;
                const limit = 1000;
                let fetchMore = true;

                console.log('Fetching Chart 4 data via pagination...');
                while (fetchMore) {
                    const url = `${SUPABASE_URL}/rest/v1/v_chart4_topic_trends?select=year,topic_id,topic_label,papers_count,series_color&order=year.asc,topic_id.asc&limit=${limit}&offset=${offset}`;

                    const response = await fetch(url, {
                        headers: {
                            'apikey': SUPABASE_KEY,
                            'Authorization': `Bearer ${SUPABASE_KEY}`
                        }
                    });

                    if (!response.ok) {
                        const errText = await response.text();
                        console.error('Chart 4 Fetch Error:', response.status, response.statusText, 'Output:', errText);
                        throw new Error(`HTTP ${response.status}: ${errText}`);
                    }

                    const pageData = await response.json();

                    if (!pageData || pageData.length === 0) {
                        fetchMore = false;
                    } else {
                        allRows = allRows.concat(pageData);
                        if (pageData.length < limit) {
                            fetchMore = false; // Last page reached
                        } else {
                            offset += limit; // Next page
                        }
                    }
                }

                if (allRows.length === 0) {
                    container.innerHTML = '<div style="display:flex;height:100%;align-items:center;justify-content:center;color:var(--text-secondary);">No data returned.</div>';
                    return;
                }

                const rawData = allRows;

                const data = rawData.map(d => ({
                    ...d,
                    year: Number(d.year),
                    papers_count: Number(d.papers_count)
                }));

                const minYear = Math.min(...data.map(d => d.year));
                const maxYear = Math.max(...data.map(d => d.year));

                console.log(`Chart 4 fetched total rows: ${data.length}, minYear: ${minYear}, maxYear: ${maxYear}`);

                // DEBUG: Validate full dataset load (expect >1000 rows, max year 2025)
                console.log('Chart 4 Total Rows:', data.length);
                if (data.length > 0) {
                    const maxYear = Math.max(...data.map(d => Number(d.year)));
                    console.log('Chart 4 Max Year:', maxYear);
                }
                // Debug sample
                console.log('Chart 4 First Row:', data[0]);

                // Clear loading
                container.innerHTML = '';

                // D3 Setup: Responsive Layout
                const rect = container.getBoundingClientRect();
                const width = rect.width || 800;
                const height = rect.height || 400;
                const margin = { top: 20, right: 30, bottom: 30, left: 40 };

                const svg = d3.select(container).append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .attr('viewBox', `0 0 ${width} ${height}`)
                    .attr('preserveAspectRatio', 'xMinYMin meet')
                    .style('overflow', 'visible');





                // Process Data: Group by Topic
                const topicsMap = d3.group(data, d => d.topic_id);
                const topicIds = Array.from(topicsMap.keys());

                // Scales
                const x = d3.scaleLinear()
                    .domain([1980, 2025])
                    .range([margin.left, width - margin.right]);

                const yMax = d3.max(data, d => Number(d.papers_count)) || 10;
                const y = d3.scaleLinear()
                    .domain([0, yMax])
                    .range([height - margin.bottom, margin.top]);

                // Axes
                const xAxis = d3.axisBottom(x).tickFormat(d3.format('d')).tickValues(d3.range(1980, 2026, 5));
                const yAxis = d3.axisLeft(y).ticks(5);

                // Style Axes
                const gx = svg.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(xAxis);
                const gy = svg.append('g').attr('transform', `translate(${margin.left},0)`).call(yAxis);

                gx.selectAll('text').attr('fill', 'var(--text-secondary)').style('font-family', 'Inter').style('font-size', '10px');
                gy.selectAll('text').attr('fill', 'var(--text-secondary)').style('font-family', 'Inter').style('font-size', '10px');
                gx.selectAll('.domain, line').attr('stroke', 'var(--text-secondary)').attr('opacity', 0.3);
                gy.selectAll('.domain, line').attr('stroke', 'var(--text-secondary)').attr('opacity', 0.3);

                // Labels
                svg.append('text').attr('x', width / 2).attr('y', height).attr('fill', 'var(--text-secondary)').style('font-size', '10px').style('text-anchor', 'middle').text('Year');
                svg.append('text').attr('transform', 'rotate(-90)').attr('x', -height / 2).attr('y', 15).attr('fill', 'var(--text-secondary)').style('font-size', '10px').style('text-anchor', 'middle').text('Papers');

                // Line Generator
                const line = d3.line()
                    .x(d => x(Number(d.year)))
                    .y(d => y(Number(d.papers_count)))
                    .curve(d3.curveMonotoneX);

                // Draw all lines
                const pathGroup = svg.append('g');

                pathGroup.selectAll('path')
                    .data(topicIds)
                    .join('path')
                    .attr('class', 'trend-line')
                    .attr('id', d => 'trend-line-' + d)
                    .attr('d', id => line(topicsMap.get(id)))
                    .attr('fill', 'none')
                    .attr('stroke', id => {
                        const tData = topicsMap.get(id)[0];
                        return tData.series_color || topicColors[(id - 1) % topicColors.length] || '#999';
                    })
                    .attr('stroke-width', 1.5)
                    .attr('opacity', 0.6)
                    .attr('stroke-linecap', 'round');

                // ============================================
                // UI: Multi-Select Logic (Moved After Render)
                // ============================================
                // Multi-Select State
                let selectedTopicIds = new Set();

                function updateChartVisuals() {
                    const hasSelection = selectedTopicIds.size > 0;

                    pathGroup.selectAll('.trend-line')
                        .each(function (id) {
                            const el = d3.select(this);
                            if (!hasSelection) {
                                el.attr('opacity', 0.6).attr('stroke-width', 1.5);
                            } else {
                                if (selectedTopicIds.has(id)) {
                                    el.attr('opacity', 1.0).attr('stroke-width', 3).raise();
                                } else {
                                    el.attr('opacity', 0.1).attr('stroke-width', 1);
                                }
                            }
                        });
                }

                // --- Render Multi-Select Dropdown ---
                const selectorContainer = document.getElementById('chart4-topic-selector');
                if (selectorContainer) {
                    // Create basic structure with Theme Variables
                    selectorContainer.innerHTML = `
                            <div id="c4-dropdown-trigger" style="
                                border: 1px solid var(--border-color, #ccc); 
                                border-radius: 6px; 
                                padding: 6px 12px; 
                                background: var(--bg-card, #fff); 
                                cursor: pointer; 
                                font-size: 13px;
                                color: var(--text-primary, #333);
                                display: flex;
                                align-items: center;
                                justify-content: space-between;
                            ">
                                <span id="c4-dropdown-label" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: 8px;">Select topics...</span>
                                <span style="font-size:10px; color:var(--text-secondary);">▼</span>
                            </div>
                            <!-- Dropdown Menu -->
                            <div id="c4-dropdown-menu" style="
                                display: none;
                                position: absolute;
                                top: 100%;
                                right: 0;
                                width: 280px; /* Wider for labels */
                                max-height: 300px;
                                overflow-y: auto;
                                background: var(--bg-card, #fff);
                                border: 1px solid var(--border-color, #ccc);
                                border-radius: 6px;
                                z-index: 1000;
                                box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* Subtler shadow */
                                margin-top: 4px;
                            ">
                                <div id="c4-clear-btn" style="
                                    padding: 8px 12px;
                                    font-size: 11px;
                                    color: #ff6b6b;
                                    cursor: pointer;
                                    border-bottom: 1px solid var(--border-color, #eee);
                                    font-weight: 600;
                                    background: rgba(255, 107, 107, 0.05);
                                    text-align: right;
                                ">Clear Selection (×)</div>
                                <div id="c4-options-list"></div>
                            </div>
                        `;

                    const trigger = document.getElementById('c4-dropdown-trigger');
                    const menu = document.getElementById('c4-dropdown-menu');
                    const label = document.getElementById('c4-dropdown-label');
                    const clearBtn = document.getElementById('c4-clear-btn');
                    const optionsList = document.getElementById('c4-options-list');

                    // Toggle Menu
                    trigger.onclick = (e) => {
                        e.stopPropagation();
                        menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
                    };

                    // Close on click outside
                    document.addEventListener('click', (e) => {
                        if (!selectorContainer.contains(e.target)) {
                            menu.style.display = 'none';
                        }
                    });

                    // Prevent click inside menu from closing it
                    menu.onclick = (e) => e.stopPropagation();


                    // Populate Options & Build Lookup Map
                    const topicLookup = {};
                    // Sort distinct topics by ID for the list
                    const uniqueTopics = Array.from(new Set(data.map(d => JSON.stringify({
                        id: d.topic_id,
                        label: d.topic_label,
                        color: d.series_color || topicColors[(d.topic_id - 1) % topicColors.length]
                    }))))
                        .map(s => JSON.parse(s))
                        .sort((a, b) => a.id - b.id);

                    uniqueTopics.forEach(t => topicLookup[t.id] = t);

                    uniqueTopics.forEach(t => {
                        const opt = document.createElement('div');
                        opt.className = 'c4-option';

                        // CLEAN LABEL LOGIC: Remove existing "Topic X:" prefix if present
                        // Regex: ^Topic \d+:\s*
                        const cleanLabel = (t.label || '').replace(/^Topic \d+:\s*/i, '').trim();

                        // Render: "Topic <id>: <Clean Name>"
                        opt.textContent = `Topic ${t.id}: ${cleanLabel}`;

                        opt.style.cssText = `
                                padding: 8px 12px;
                                font-size: 12px;
                                color: var(--text-secondary);
                                cursor: pointer;
                                border-bottom: 1px solid var(--border-color, #eee);
                                transition: background 0.1s;
                            `;
                        opt.dataset.tid = t.id;

                        opt.onmouseover = () => { opt.style.background = 'var(--bg-hover, #f5f5f5)'; };
                        opt.onmouseout = () => { opt.style.background = 'transparent'; };

                        opt.onclick = (e) => {
                            e.stopPropagation();
                            const tid = Number(t.id);
                            if (selectedTopicIds.has(tid)) {
                                selectedTopicIds.delete(tid);
                                opt.style.color = 'var(--text-secondary)';
                                opt.style.fontWeight = 'normal';
                                opt.textContent = opt.textContent.replace('✓ ', '');
                            } else {
                                selectedTopicIds.add(tid);
                                opt.style.color = 'var(--accent-color)';
                                opt.style.fontWeight = 'bold';
                                opt.textContent = '✓ ' + opt.textContent;
                            }
                            updateSelectionState();
                        };
                        optionsList.appendChild(opt);
                    });

                    // Clear Action
                    clearBtn.onclick = (e) => {
                        e.stopPropagation();
                        selectedTopicIds.clear();
                        // Reset UI
                        Array.from(optionsList.children).forEach(child => {
                            child.style.color = 'var(--text-secondary)';
                            child.style.fontWeight = 'normal';
                            child.textContent = child.textContent.replace('✓ ', '');
                        });
                        updateSelectionState();
                        menu.style.display = 'none';
                    };

                    function updateSelectionState() {
                        const tagContainer = document.getElementById('chart4-topic-tags');

                        // Update Trigger Label
                        if (selectedTopicIds.size === 0) {
                            label.textContent = 'Select topics...';
                            label.style.color = 'var(--text-primary)';

                            // Render Empty State Placeholder Tag
                            if (tagContainer) {
                                tagContainer.innerHTML = '<span style="display:inline-flex; align-items:center; height:24px; padding:0 12px; border-radius:12px; font-size:11px; font-weight:500; background:var(--bg-card); border:1px solid var(--border-color); color:var(--text-secondary); opacity:0.7;">All topics visible</span>';
                            }
                        } else {
                            label.textContent = `${selectedTopicIds.size} topics selected`;
                            label.style.color = 'var(--accent-color)';

                            // Render Tags
                            if (tagContainer) {
                                tagContainer.innerHTML = '';
                                const sortedIds = Array.from(selectedTopicIds).sort((a, b) => a - b);

                                sortedIds.forEach(tid => {
                                    const meta = topicLookup[tid] || { label: 'Unknown', color: '#ccc' };

                                    // Standardize label for Tag
                                    let rawLabel = meta.label || '';
                                    const cleanLabel = rawLabel.replace(/^Topic \d+:\s*/i, '').trim();
                                    const displayLabel = `Topic ${tid}: ${cleanLabel}`;

                                    const tag = document.createElement('div');
                                    tag.style.cssText = `
                                            display: inline-flex;
                                            align-items: center;
                                            height: 26px;
                                            padding: 0 10px 0 12px;
                                            border-radius: 13px;
                                            font-size: 12px;
                                            font-weight: 500;
                                            background: var(--bg-card);
                                            border: 1px solid var(--border-color);
                                            color: var(--text-primary);
                                            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
                                            white-space: nowrap;
                                        `;

                                    tag.innerHTML = `
                                            <span style="width:8px; height:8px; border-radius:50%; background:${meta.color}; margin-right:8px;"></span>
                                            ${displayLabel}
                                            <span class="tag-close" style="
                                                margin-left: 8px;
                                                cursor: pointer;
                                                color: var(--text-secondary);
                                                font-size: 16px;
                                                display: flex;
                                                align-items: center;
                                                justify-content: center;
                                                width: 18px; 
                                                height: 18px;
                                                border-radius: 50%;
                                                opacity: 0.7;
                                            " title="Remove">×</span>
                                        `;

                                    // Hover effect for close btn
                                    const closeBtn = tag.querySelector('.tag-close');
                                    closeBtn.onmouseover = () => { closeBtn.style.background = 'var(--bg-hover, #eee)'; closeBtn.style.opacity = '1'; };
                                    closeBtn.onmouseout = () => { closeBtn.style.background = 'transparent'; closeBtn.style.opacity = '0.7'; };

                                    closeBtn.onclick = (e) => {
                                        e.stopPropagation();
                                        selectedTopicIds.delete(tid);

                                        // Untick in dropdown
                                        const opt = optionsList.querySelector(`div[data-tid="${tid}"]`);
                                        if (opt) {
                                            opt.style.color = 'var(--text-secondary)';
                                            opt.style.fontWeight = 'normal';
                                            opt.textContent = opt.textContent.replace('✓ ', '');
                                        }
                                        updateSelectionState();
                                    };

                                    tagContainer.appendChild(tag);
                                });
                            }
                        }

                        // Update Chart Visuals
                        updateChartVisuals();
                    }

                    // Initial Call
                    updateSelectionState();
                }

                // Interaction Layer
                const overlay = svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'transparent')
                    .style('cursor', 'crosshair');

                let pinnedId = null;

                overlay.on('mousemove', function (event) {
                    if (pinnedId) return; // If pinned, ignore hover

                    const [mx, my] = d3.pointer(event);

                    // 1. Find Year
                    const year = Math.round(x.invert(mx));
                    if (year < 1980 || year > 2025) return;

                    // 2. Find closest topic at this year
                    let bestTopic = null;
                    let minDiff = Infinity;

                    topicIds.forEach(id => {
                        const rows = topicsMap.get(id);
                        // Simple find for row
                        const row = rows.find(r => Number(r.year) === year);
                        if (row) {
                            const py = y(Number(row.papers_count));
                            const diff = Math.abs(py - my);
                            if (diff < minDiff) {
                                minDiff = diff;
                                bestTopic = row;
                            }
                        }
                    });

                    if (bestTopic) {
                        highlightTopic(bestTopic.topic_id, bestTopic);
                    }
                })
                    .on('mouseleave', function () {
                        if (!pinnedId) resetHighlight();
                    })
                    .on('click', function (event) {
                        const [mx, my] = d3.pointer(event);
                        const year = Math.round(x.invert(mx));
                        if (year < 1980 || year > 2025) return;

                        let bestTopic = null;
                        let minDiff = Infinity;
                        topicIds.forEach(id => {
                            const rows = topicsMap.get(id);
                            const row = rows.find(r => Number(r.year) === year);
                            if (row) {
                                const diff = Math.abs(y(Number(row.papers_count)) - my);
                                if (diff < minDiff) { minDiff = diff; bestTopic = row; }
                            }
                        });

                        if (bestTopic) {
                            if (pinnedId === bestTopic.topic_id) {
                                pinnedId = null; // Unpin
                                resetHighlight();
                            } else {
                                pinnedId = bestTopic.topic_id;
                                highlightTopic(pinnedId, bestTopic);
                            }
                        } else {
                            pinnedId = null;
                            resetHighlight();
                        }
                    });

                function highlightTopic(tId, pointData) {
                    // Priority Check: If multi-selection is active,
                    // ONLY allow highlighting/focus if the hovered topic is in the selection.
                    // Or, allow hover to temporarily "peek" but respect the faded items.
                    // Impl: If selection active, and hovered item is NOT selected, do nothing special (keep filtered).
                    // If selection active, and hovered item IS selected, maybe thicken it?
                    // If NO selection, standard behaviour (dim others).

                    const hasSelection = selectedTopicIds.size > 0;

                    if (hasSelection) {
                        // If we have a selection filter, we generally preserve the "selected" view.
                        // Hovering on a non-selected item should not abruptly hide the selected ones.
                        // Design Choice: If selection is active, ignore hover effects on non-selected items.
                        // Only show tooltip for hovered item.

                        // Visuals: Only update tooltip, don't change opacity unless needed.
                        if (pointData) {
                            // Fix duplicated label
                            let labelStr = pointData.topic_label || '';
                            if (labelStr.startsWith(`Topic ${tId}:`)) {
                                // already prefixed, do nothing
                            } else {
                                // prefix nicely
                                labelStr = `Topic ${tId}: ${labelStr}`;
                            }

                            legend.innerHTML = `<span style="font-weight:700; color:${pointData.series_color || '#fff'}">${labelStr}</span> &bull; ${pointData.year}: ${pointData.papers_count} papers`;

                            const tooltip = d3.select('#temporal-tooltip');
                            tooltip.style('opacity', 1)
                                .style('left', (event.pageX + 15) + 'px')
                                .style('top', (event.pageY - 15) + 'px')
                                .html(`<strong>${labelStr}</strong><br>Year: ${pointData.year}<br>Papers: ${pointData.papers_count}`);
                        }
                        return; // Skip the opacity manipulation below
                    }


                    // Standard Behaviour (No Multi-Select)
                    pathGroup.selectAll('.trend-line')
                        .attr('opacity', 0.1)
                        .attr('stroke-width', 1);

                    const activePath = pathGroup.select('#trend-line-' + tId);
                    activePath
                        .attr('opacity', 1)
                        .attr('stroke-width', 3)
                        .raise();

                    if (pointData) {
                        // Fix duplicated label
                        let labelStr = pointData.topic_label || '';
                        if (!labelStr.startsWith(`Topic ${tId}:`)) {
                            labelStr = `Topic ${tId}: ${labelStr}`;
                        }

                        legend.innerHTML = `<span style="font-weight:700; color:${pointData.series_color || '#fff'}">${labelStr}</span> &bull; ${pointData.year}: ${pointData.papers_count} papers`;

                        const tooltip = d3.select('#temporal-tooltip');
                        tooltip.style('opacity', 1)
                            .style('left', (event.pageX + 15) + 'px')
                            .style('top', (event.pageY - 15) + 'px')
                            .html(`<strong>${labelStr}</strong><br>Year: ${pointData.year}<br>Papers: ${pointData.papers_count}`);
                    }
                }

                function resetHighlight() {
                    // If selection exists, revert to selection view
                    // If no selection, revert to all visible
                    updateChartVisuals();

                    legend.innerHTML = '&nbsp;';
                    d3.select('#temporal-tooltip').style('opacity', 0);
                }



            } catch (e) {
                console.error('Error loading Chart 4:', e);
                container.innerHTML = `<div style="color:red;padding:20px;">Error: ${e.message}</div>`;
            }
        }

        // Chart 5: Bigram Trends (Single Selected Topic)
        async function fetchAndRenderBigramTrends() {
            const container = document.getElementById('bigram-trends-chart');
            const selectorContainer = document.getElementById('chart5-topic-selector');
            const legendContainer = document.getElementById('bigram-trends-legend');

            if (!container || !selectorContainer) return;

            // 1. Fetch distinct topics for dropdown
            let topics = [];
            try {
                const tUrl = `${SUPABASE_URL}/rest/v1/topics?select=id,label,color&order=id.asc`;
                const tRes = await fetch(tUrl, { headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` } });
                if (tRes.ok) topics = await tRes.json();
            } catch (e) { console.warn("Failed to load topics for Chart 5", e); }

            // --- Render Dropdown ---
            // State
            let currentTopicId = topics.length > 0 ? topics[0].id : 1;

            function renderDropdown() {
                if (!topics.length) {
                    selectorContainer.innerHTML = 'No topics found.';
                    return;
                }

                const currentTopic = topics.find(t => t.id === currentTopicId) || topics[0];
                const cleanLabel = (currentTopic.label || '').replace(/^Topic \d+:\s*/i, '').trim();
                const displayLabel = `Topic ${currentTopic.id}: ${cleanLabel}`;

                selectorContainer.innerHTML = `
                        <div id="c5-dropdown-trigger" style="
                            border: 1px solid var(--border-color, #ccc); 
                            border-radius: 6px; 
                            padding: 6px 12px; 
                            background: var(--bg-card, #fff); 
                            cursor: pointer; 
                            font-size: 13px;
                            color: var(--text-primary, #333);
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                        ">
                            <span id="c5-dropdown-label" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: 8px;">${displayLabel}</span>
                            <span style="font-size:10px; color:var(--text-secondary);">▼</span>
                        </div>
                        <div id="c5-dropdown-menu" style="
                            display: none;
                            position: absolute;
                            top: 100%;
                            right: 0;
                            width: 280px; 
                            max-height: 300px;
                            overflow-y: auto;
                            background: var(--bg-card, #fff);
                            border: 1px solid var(--border-color, #ccc);
                            border-radius: 6px;
                            z-index: 1000;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
                            margin-top: 4px;
                        ">
                             <div id="c5-options-list"></div>
                        </div>
                    `;

                const trigger = document.getElementById('c5-dropdown-trigger');
                const menu = document.getElementById('c5-dropdown-menu');
                const list = document.getElementById('c5-options-list');

                trigger.onclick = (e) => {
                    e.stopPropagation();
                    menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
                };

                document.addEventListener('click', (e) => {
                    if (selectorContainer && !selectorContainer.contains(e.target)) menu.style.display = 'none';
                });
                menu.onclick = (e) => e.stopPropagation();

                topics.forEach(t => {
                    const opt = document.createElement('div');
                    const l = (t.label || '').replace(/^Topic \d+:\s*/i, '').trim();
                    opt.textContent = `Topic ${t.id}: ${l}`;
                    opt.style.cssText = `
                            padding: 8px 12px;
                            font-size: 12px;
                            color: var(--text-secondary);
                            cursor: pointer;
                            border-bottom: 1px solid var(--border-color, #eee);
                            transition: background 0.1s;
                        `;
                    if (t.id === currentTopicId) {
                        opt.style.color = 'var(--accent-color)';
                        opt.style.fontWeight = 'bold';
                    }

                    opt.onmouseover = () => { opt.style.background = 'var(--bg-hover, #f5f5f5)'; };
                    opt.onmouseout = () => { opt.style.background = 'transparent'; };
                    opt.onclick = () => {
                        currentTopicId = t.id;
                        menu.style.display = 'none';
                        renderDropdown(); // Update label
                        loadChartData(currentTopicId); // Fetch new data
                    };
                    list.appendChild(opt);
                });
            }

            renderDropdown();
            if (topics.length > 0) loadChartData(topics[0].id);


            async function loadChartData(topicId) {
                container.innerHTML = '<div style="display:flex;height:100%;align-items:center;justify-content:center;color:var(--text-secondary);">Loading bigrams...</div>';
                if (legendContainer) legendContainer.innerHTML = '';

                try {
                    const url = `${SUPABASE_URL}/rest/v1/v_chart5_bigram_trends?topic_id=eq.${topicId}&order=year.asc,bigram_rank.asc`;
                    const response = await fetch(url, { headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` } });
                    if (!response.ok) throw new Error("Fetch failed");

                    const data = await response.json();
                    if (!data || data.length === 0) {
                        container.innerHTML = '<div style="display:flex;height:100%;align-items:center;justify-content:center;color:var(--text-secondary);">No bigram data for this topic.</div>';
                        return;
                    }

                    renderChart(data);
                } catch (e) {
                    console.error("Chart 5 Error:", e);
                    container.innerHTML = '<div style="color:var(--text-secondary); font-style:italic; padding:20px; text-align:center;">Error loading bigram trends.</div>';
                }
            }

            function renderChart(data) {
                container.innerHTML = '';

                // Group by bigram
                const bigramMap = d3.group(data, d => d.bigram);
                const bigrams = Array.from(bigramMap.keys());

                // Palette
                const bigramColors = ['#4cc9f0', '#f72585', '#3a0ca3', '#4361ee', '#7209b7'];
                const colorScale = d3.scaleOrdinal().domain(bigrams).range(bigramColors);

                // D3 Setup
                const rect = container.getBoundingClientRect();
                const width = rect.width || 800;
                const height = rect.height || 400;
                const margin = { top: 20, right: 30, bottom: 40, left: 40 };

                const svg = d3.select(container).append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .attr('viewBox', `0 0 ${width} ${height}`)
                    .attr('preserveAspectRatio', 'xMinYMin meet')
                    .style('overflow', 'visible');

                const x = d3.scaleLinear().domain([1980, 2025]).range([margin.left, width - margin.right]);
                const yMax = d3.max(data, d => d.value) || 5;
                const y = d3.scaleLinear().domain([0, yMax]).range([height - margin.bottom, margin.top]);

                // Axes
                const xAxis = d3.axisBottom(x).tickFormat(d3.format('d')).tickValues(d3.range(1980, 2026, 5));
                const yAxis = d3.axisLeft(y).ticks(5);

                const gx = svg.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(xAxis);
                const gy = svg.append('g').attr('transform', `translate(${margin.left},0)`).call(yAxis);

                gx.selectAll('text').attr('fill', 'var(--text-secondary)').style('font-family', 'Inter').style('font-size', '10px');
                gy.selectAll('text').attr('fill', 'var(--text-secondary)').style('font-family', 'Inter').style('font-size', '10px');
                gx.selectAll('.domain, line').attr('stroke', 'var(--text-secondary)').attr('opacity', 0.2);
                gy.selectAll('.domain, line').attr('stroke', 'var(--text-secondary)').attr('opacity', 0.2);

                // Labels
                svg.append('text').attr('x', width / 2).attr('y', height).attr('fill', 'var(--text-secondary)').style('font-size', '10px').style('text-anchor', 'middle').text('Year');
                svg.append('text').attr('transform', 'rotate(-90)').attr('x', -height / 2).attr('y', 15).attr('fill', 'var(--text-secondary)').style('font-size', '10px').style('text-anchor', 'middle').text('Frequency');

                const line = d3.line()
                    .x(d => x(d.year))
                    .y(d => y(d.value))
                    .curve(d3.curveMonotoneX);

                const linesGroup = svg.append('g');

                linesGroup.selectAll('.bg-line')
                    .data(bigrams)
                    .join('path')
                    .attr('class', 'bg-line')
                    .attr('fill', 'none')
                    .attr('stroke', d => colorScale(d))
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.8)
                    .attr('d', d => line(bigramMap.get(d)))
                    // Hover interactions
                    .on('mouseover', function (event, d) {
                        // Fade others
                        linesGroup.selectAll('.bg-line').attr('opacity', 0.15);
                        d3.select(this).attr('opacity', 1).attr('stroke-width', 3).raise();
                    })
                    .on('mouseout', function () {
                        linesGroup.selectAll('.bg-line').attr('opacity', 0.8).attr('stroke-width', 2);
                    });

                // Interaction Overlay
                const overlay = svg.append('rect')
                    .attr('width', width - margin.left - margin.right)
                    .attr('height', height - margin.top - margin.bottom)
                    .attr('x', margin.left)
                    .attr('y', margin.top)
                    .attr('fill', 'transparent')
                    .style('cursor', 'crosshair');

                overlay.on('mousemove', function (event) {
                    const [mx, my] = d3.pointer(event);
                    const year = Math.round(x.invert(mx));
                    if (year < 1980 || year > 2025) return;

                    // Find values at this year
                    let tooltipHtml = `<strong>Year: ${year}</strong><br>`;
                    let found = false;

                    // Sort by value DESC
                    const snapshot = [];
                    bigrams.forEach(b => {
                        const row = bigramMap.get(b).find(r => r.year === year);
                        if (row) snapshot.push({ bigram: b, val: row.value, color: colorScale(b) });
                    });
                    snapshot.sort((a, b) => b.val - a.val);

                    snapshot.forEach(s => {
                        if (s.val > 0) found = true;
                        tooltipHtml += `<span style="color:${s.color}">●</span> ${s.bigram}: ${s.val}<br>`;
                    });

                    const tt = d3.select('#temporal-tooltip');
                    if (found) {
                        tt.style('opacity', 1).html(tooltipHtml)
                            .style('left', (event.pageX + 15) + 'px')
                            .style('top', (event.pageY - 20) + 'px');
                    } else {
                        tt.style('opacity', 0);
                    }
                }).on('mouseleave', () => {
                    d3.select('#temporal-tooltip').style('opacity', 0);
                });

                // Legend
                if (legendContainer) {
                    legendContainer.innerHTML = '';
                    bigrams.forEach(b => {
                        const item = document.createElement('span');
                        item.style.cssText = `display:inline-flex; align-items:center; margin:0 8px; color:var(--text-secondary); font-size:11px;`;
                        item.innerHTML = `<span style="width:8px; height:8px; border-radius:50%; background:${colorScale(b)}; margin-right:4px;"></span> ${b}`;
                        legendContainer.appendChild(item);
                    });
                }
            }
        }



        // -------------------------------------------------------------------------
        // INDIVIDUAL TOPIC DASHBOARD LOGIC
        // -------------------------------------------------------------------------
        let topicPapers = [];
        let topicPapersPage = 1;

        async function initIndividualTopicDashboard() {
            const topicId = urlState.topicId;
            if (!topicId) return;

            console.log(`📊 Initializing Individual Topic Dashboard for Topic ${topicId}`);

            // 1. Move Canvas Logic
            const canvasContainer = document.getElementById('topic-network-container');
            if (canvasContainer) {
                // Force display block to get dimensions
                document.getElementById('view-topic').style.display = 'block';

                // RESET GLOBAL INTERACTION STATE to prevent tooltip conflicts
                activeSpotlights.clear();
                selectedNode = null;
                searchTerm = '';
                // Reset transform to default to ensure coordinates are aligned
                if (zoom && canvas) {
                    d3.select(canvas).call(zoom.transform, d3.zoomIdentity);
                    transform = d3.zoomIdentity;
                }

                const rect = canvasContainer.getBoundingClientRect();
                if (rect.width > 0) {
                    width = rect.width;
                    height = rect.height;
                    canvas.width = width;
                    canvas.height = height;
                    canvasContainer.appendChild(canvas);
                    canvas.style.position = 'absolute';
                }
            }

            // Switch View (visually)
            switchView('topic');

            // 2. Populate Data
            const topic = allData.topics[0] || { id: topicId, topic_name: 'Unknown Topic' };

            // Header
            const titleEl = document.getElementById('topic-brief-title');
            const subEl = document.getElementById('topic-brief-subtitle');
            const defEl = document.getElementById('topic-brief-definition');

            if (titleEl) titleEl.textContent = topic.topic_name || topic.name;
            if (subEl) subEl.textContent = `Topic ${topic.id}`;
            if (defEl) defEl.innerHTML = topic.definition || "No definition available.";

            // --- BREADCRUMB UPDATE (Override switchView) ---
            const bc = document.querySelector('.stitch-bc-current');
            if (bc) {
                const rawName = topic.topic_name || topic.name || 'Unknown';
                const cleanName = rawName.replace(/^Topic \d+:\s*/, '').replace(/^Topic undefined:\s*/, '');
                bc.textContent = `TOPIC ${topic.id}: ${cleanName}`;
            }

            // Top Terms - Metadata Added
            const sortedBigrams = [...allData.bigrams]
                .sort((a, b) => (b.normalized_frequency || 0) - (a.normalized_frequency || 0))
                .slice(0, 5);

            // Calculate total frequency for this topic to compute share
            const totalTopicFreq = allData.bigrams.reduce((sum, b) => sum + (b.normalized_frequency || 0), 0);

            const termsContainer = document.getElementById('topic-top-terms');
            if (termsContainer) {
                if (sortedBigrams.length === 0) termsContainer.innerHTML = '<span style="color:var(--text-secondary);font-size:12px">No terms available</span>';
                else {
                    const allBigramsTotal = allData.bigrams.reduce((sum, b) => sum + (b.frequency_sum || b.weight || 0), 0);

                    termsContainer.innerHTML = sortedBigrams.map(b => {
                        // Use frequency_sum for count, fallback to weight if missing
                        const occurrences = b.frequency_sum || b.weight || Math.round(b.normalized_frequency || 0);
                        const share = allBigramsTotal > 0 ? ((occurrences / allBigramsTotal) * 100).toFixed(1) : '0.0';

                        // Using a chip-like container but with secondary metadata line
                        return `
                                <div style="display:inline-flex; flex-direction:column; background:rgba(255,255,255,0.05); border:1px solid var(--chart-panel-border); padding:6px 12px; border-radius:8px; margin-right:8px; margin-bottom:8px;">
                                    <span style="font-size:13px; color:var(--text-primary); font-weight:500;">${b.bigram}</span>
                                    <span style="font-size:10px; color:var(--text-secondary); margin-top:2px;">
                                        Total occurrences: ${occurrences} • Share: ${share}%
                                    </span>
                                </div>
                            `;
                    }).join('');
                }
            }

            // Trends Chart
            renderTopicTrendsChart(topicId, sortedBigrams);

            // Papers Table
            topicPapers = allData.papers.sort((a, b) => (b.year || 0) - (a.year || 0));
            topicPapersPage = 1;
            renderTopicPapersTable();

            // Navigation
            setupTopicNavigation(topicId);

            // Bind Topic Zoom Controls
            const zIn = document.getElementById('topic-zoom-in');
            const zOut = document.getElementById('topic-zoom-out');
            if (zIn) zIn.onclick = () => { if (zoom) d3.select(canvas).transition().call(zoom.scaleBy, 1.3); };
            if (zOut) zOut.onclick = () => { if (zoom) d3.select(canvas).transition().call(zoom.scaleBy, 0.7); };
        }

        function setupTopicNavigation(currentTopicId) {
            const prevBtn = document.getElementById('prev-topic-btn');
            const nextBtn = document.getElementById('next-topic-btn');

            if (!window.globalAllTopics) {
                // Try to use allData.topics if global missing (fallback)
                window.globalAllTopics = [...allData.topics];
            }

            const allTopics = window.globalAllTopics;
            if (!allTopics || allTopics.length === 0) return;

            const sorted = [...allTopics].sort((a, b) => a.id - b.id);
            const idx = sorted.findIndex(t => t.id === currentTopicId);

            if (prevBtn) {
                prevBtn.onclick = () => {
                    const t = sorted[(idx - 1 + sorted.length) % sorted.length];
                    window.location.search = `?mode=topic&embed=${isEmbedMode}&topicId=${t.id}`;
                };
            }
            if (nextBtn) {
                nextBtn.onclick = () => {
                    const t = sorted[(idx + 1) % sorted.length];
                    window.location.search = `?mode=topic&embed=${isEmbedMode}&topicId=${t.id}`;
                };
            }
        }

        function renderTopicPapersTable() {
            const tbody = document.getElementById('topic-papers-tbody');
            const headers = document.getElementById('topic-papers-table'); // Actually we need to change #topic-papers-title
            const titleHeader = document.getElementById('topic-papers-title');

            const info = document.getElementById('papers-page-info');
            const prev = document.getElementById('papers-prev-btn');
            const next = document.getElementById('papers-next-btn');

            if (titleHeader) {
                titleHeader.textContent = `Papers informing this topic (${topicPapers.length} papers)`;
            }

            if (!tbody) return;
            tbody.innerHTML = '';

            const size = 50;
            const total = Math.ceil(topicPapers.length / size) || 1;
            if (topicPapersPage < 1) topicPapersPage = 1;
            if (topicPapersPage > total) topicPapersPage = total;

            const chunk = topicPapers.slice((topicPapersPage - 1) * size, topicPapersPage * size);

            chunk.forEach(p => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid var(--chart-row-border)';

                const title = p.title || 'Untitled';

                row.innerHTML = `
                        <td style="padding:12px;color:var(--text-secondary);font-size:13px;vertical-align:top;">${p.year || ''}</td>
                        <td style="padding:12px;color:var(--text-primary);font-size:13px;font-weight:500;word-break:break-word;vertical-align:top;line-height:1.5;">${title}</td>
                        <td style="padding:12px;color:var(--text-secondary);font-size:13px;vertical-align:top;">${p.authors || 'Unknown'}</td>
                        <td style="padding:12px;color:var(--text-secondary);font-size:13px;vertical-align:top;font-style:italic;">${p.journal || ''}</td>
                        <td style="padding:12px;vertical-align:top;text-align:right;">
                            <button class="btn expand-btn" style="width:24px;height:24px;padding:0;display:flex;align-items:center;justify-content:center;border-radius:4px;">▼</button>
                        </td>
                    `;

                const absRow = document.createElement('tr');
                absRow.style.display = 'none';
                absRow.innerHTML = `
                        <td colspan="5" style="padding:0 12px 24px 12px;border-bottom:1px solid var(--chart-row-border);">
                            <div style="background:rgba(255,255,255,0.03);padding:16px;border-radius:8px;color:var(--text-secondary);font-size:13px;line-height:1.6;">
                                <strong style="color:var(--text-primary);display:block;margin-bottom:8px;">Abstract</strong>
                                ${p.abstract || 'No abstract available.'}
                            </div>
                        </td>
                    `;

                row.querySelector('.expand-btn').onclick = function () {
                    const isHidden = absRow.style.display === 'none';
                    absRow.style.display = isHidden ? 'table-row' : 'none';
                    this.textContent = isHidden ? '▲' : '▼';
                };

                tbody.appendChild(row);
                tbody.appendChild(absRow);
            });

            if (info) info.textContent = `Page ${topicPapersPage} / ${total}`;

            if (prev) {
                prev.disabled = topicPapersPage <= 1;
                prev.onclick = () => {
                    if (topicPapersPage > 1) { topicPapersPage--; renderTopicPapersTable(); }
                };
            }
            if (next) {
                next.disabled = topicPapersPage >= total;
                next.onclick = () => {
                    if (topicPapersPage < total) { topicPapersPage++; renderTopicPapersTable(); }
                };
            }
        }

        async function renderTopicTrendsChart(topicId, topBigrams) {
            const container = document.getElementById('topic-trends-chart-container');
            if (!container || !topBigrams.length) return;

            container.innerHTML = 'Loading trends...';

            try {
                const idsIdx = `(${topBigrams.map(b => b.id).join(',')})`;
                // Re-use logic: fetch bigram trends for these IDs
                // Manually constructing fetching logic since helper is rigid
                const response = await fetch(`${SUPABASE_URL}/rest/v1/v_chart5_bigram_trends?select=*&bigram_id=in.${idsIdx}&limit=2000`, {
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`
                    }
                });

                const data = await response.json();
                container.innerHTML = '';

                if (!data || !data.length) {
                    // Try querying with 'phrase' column if 'bigram' failed or is different structure
                    // But actually it's likely just empty data for this range/IDs, or mapping issue.
                    // Fallback message as requested.
                    container.innerHTML = `
                            <div style="height:100%; display:flex; align-items:center; justify-content:center; flex-direction:column; color:var(--text-secondary);">
                                <span style="font-size:13px; margin-bottom:4px;">No trend data available for these terms.</span>
                                <span style="font-size:11px; opacity:0.7;">(Dataset 'v_chart5_bigram_trends' may be missing or empty for IDs ${topBigrams.map(b => b.id).join(',')})</span>
                            </div>
                         `;
                    return;
                }

                // Render with D3
                const w = container.offsetWidth;
                const h = container.offsetHeight;
                const margin = { top: 20, right: 100, bottom: 30, left: 40 };
                const svg = d3.select(container).append('svg').attr('width', w).attr('height', h);

                const x = d3.scaleLinear().domain([1980, 2025]).range([margin.left, w - margin.right]);
                const y = d3.scaleLinear().domain([0, d3.max(data, d => d.normalized_frequency)]).nice().range([h - margin.bottom, margin.top]);

                // Axis
                svg.append("g").attr("transform", `translate(0,${h - margin.bottom})`).call(d3.axisBottom(x).ticks(5).tickFormat(d3.format("d"))).attr("color", "#666");
                svg.append("g").attr("transform", `translate(${margin.left},0)`).call(d3.axisLeft(y).ticks(5)).attr("color", "#666");

                // Lines
                const grouped = d3.group(data, d => d.bigram_id);
                const colorScale = d3.scaleOrdinal(d3.schemeTableau10);

                grouped.forEach((vals, bid) => {
                    vals.sort((a, b) => a.year - b.year);
                    const bName = topBigrams.find(b => b.id == bid)?.bigram || 'Unknown';
                    const color = colorScale(bid);

                    svg.append("path")
                        .datum(vals)
                        .attr("fill", "none")
                        .attr("stroke", color)
                        .attr("stroke-width", 2)
                        .attr("d", d3.line().x(d => x(d.year)).y(d => y(d.normalized_frequency)));

                    // Label
                    if (vals.length) {
                        const last = vals[vals.length - 1];
                        svg.append("text")
                            .attr("x", x(last.year) + 5).attr("y", y(last.normalized_frequency))
                            .attr("fill", color)
                            .style("font-size", "10px")
                            .text(bName);
                    }
                });

            } catch (e) {
                console.error(e);
                container.innerHTML = 'Error loading trends.';
            }
        }

        // Global Navigation Helper
        window.goHome = function () {
            // Check if we are in Topic Mode (via URL)
            const params = new URLSearchParams(window.location.search);
            if (params.get('mode') === 'topic') {
                window.location.href = 'index.html';
            } else {
                switchView('network');
            }
        };

        // Global Lifecycle Hooks
        window.pauseNetwork = function () {
            console.log('Network paused');
            if (typeof animationFrame !== 'undefined' && animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            if (typeof simulation !== 'undefined' && simulation) {
                simulation.stop();
            }
        };

        window.resumeNetwork = function () {
            // Only resume if already initialized (simulation exists)
            if (typeof simulation === 'undefined' || !simulation) return;

            console.log('Network resumed');
            if (typeof animate === 'function' && !animationFrame) {
                animate(); // Kickstart RAF
            }
            if (typeof simulation !== 'undefined' && simulation) {
                simulation.alpha(1).restart();
            }
        };

        // Global Views Helper
        window.hideAllMainViews = function () {
            const containerEl = document.getElementById('container');
            const canvasEl = document.getElementById('canvas');
            const tView = document.getElementById('view-temporal');
            const libView = document.getElementById('view-library');
            const topicView = document.getElementById('view-topic');

            if (containerEl) containerEl.style.display = 'none';
            if (canvasEl) canvasEl.style.display = 'none';
            if (tView) tView.style.display = 'none';
            if (libView) libView.style.display = 'none';
            if (topicView) topicView.style.display = 'none';
        };

        // Global Switch View Function
        window.switchView = function (view) {
            // Update Nav Active State
            document.querySelectorAll('.stitch-sub-link').forEach(el => el.classList.remove('active'));
            const nav = document.getElementById('nav-' + view);
            if (nav) nav.classList.add('active');

            // Update Breadcrumb
            const bc = document.querySelector('.stitch-bc-current');
            if (bc) bc.textContent = view === 'network' ? 'NETWORK VIEW' :
                view === 'temporal' ? 'TEMPORAL EVOLUTION' :
                    view === 'library' ? 'PAPER LIBRARY' : view.toUpperCase();

            // 1) Hide all views
            window.hideAllMainViews();

            // Pause or Resume network based on whether canvas is needed
            if (view === 'network' || view === 'topic') {
                window.resumeNetwork();
            } else {
                window.pauseNetwork();
            }

            // 2) Show only the selected container
            const containerEl = document.getElementById('container');
            const canvasEl = document.getElementById('canvas');
            const networkCol = document.querySelector('.dashboard-sidebar-col');
            const contentCol = document.querySelector('.dashboard-content-col');
            const tView = document.getElementById('view-temporal');
            const libView = document.getElementById('view-library');
            const topicView = document.getElementById('view-topic');

            // Handle sidebar disabled state
            const disabledViews = ['temporal', 'library', 'field-structure'];
            if (networkCol) {
                if (disabledViews.includes(view)) {
                    networkCol.classList.add('is-disabled');
                } else {
                    networkCol.classList.remove('is-disabled');
                }
            }

            // Handle single-column override logic (e.g., Paper Library)
            if (contentCol) {
                if (view === 'library') {
                    contentCol.classList.add('layout-single');
                } else {
                    contentCol.classList.remove('layout-single');
                }
            }

            if (view === 'temporal') {
                if (tView) tView.style.display = 'block';
                // Preserving existing logic
                if (typeof loadTemporalView !== 'undefined') loadTemporalView();
            } else if (view === 'topic') {
                if (containerEl) containerEl.style.display = 'block';
                if (topicView) topicView.style.display = 'block';
                if (canvasEl) canvasEl.style.display = 'block'; // Topic view needs canvas
            } else if (view === 'library') {
                if (libView) {
                    libView.style.display = 'block';
                    libView.style.visibility = 'visible';
                    libView.style.pointerEvents = 'auto'; // Ensure clickable
                }
                // Preserving existing logic
                if (typeof LibraryManager !== 'undefined') LibraryManager.init();
            } else if (view === 'network') {
                if (containerEl) containerEl.style.display = 'block';
                // Ensure canvas is back in main container (preserving existing logic)
                const container = document.getElementById('container');
                if (container && canvas && canvas.parentElement !== container) {
                    container.appendChild(canvas);
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
                if (canvasEl) canvasEl.style.display = 'block';
            }

            // 3) VIEW LAYOUT AUDIT
            console.group('VIEW LAYOUT AUDIT');
            console.log('viewName:', view);
            console.log('sidebar display + disabled state:', networkCol ? `${getComputedStyle(networkCol).display} (${networkCol.classList.contains('is-disabled') ? 'disabled' : 'active'})` : 'N/A');
            console.log('main container class state:', contentCol ? `layout-single: ${contentCol.classList.contains('layout-single')}` : 'N/A');
            console.log('network viewport wrapper display:', containerEl ? getComputedStyle(containerEl).display : 'N/A');
            console.log('#view-library display:', libView ? getComputedStyle(libView).display : 'N/A');
            console.groupEnd();
        };


        // Modal Functions for Temporal Chart
        window.openTemporalModal = function () {
            const modal = document.getElementById('temporal-modal');
            if (!modal || !window.temporalData) return;

            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Lock scroll
            // Render chart in modal with slight delay to ensure flex layout is calcualted
            setTimeout(() => {
                renderTemporalChart(
                    window.temporalData,
                    'modal-chart-container',
                    'modal-legend-container',
                    'flex'
                );
            }, 10);
        };

        window.closeTemporalModal = function () {
            const modal = document.getElementById('temporal-modal');
            if (modal) {
                modal.style.display = 'none';
                document.body.style.overflow = ''; // Restore scroll
            }
        };

        // Close on outside click or ESC
        window.addEventListener('click', function (event) {
            const modal = document.getElementById('temporal-modal');
            if (event.target == modal) {
                closeTemporalModal();
            }
        });

        document.addEventListener('keydown', function (event) {
            if (event.key === "Escape") {
                closeTemporalModal();
            }
        });

        // --- PAPER LIBRARY MANAGER ---
        const LibraryManager = {
            currentPage: 1,
            pageSize: 50,
            sortKey: 'year',
            sortAsc: false,
            searchQuery: '',
            filteredPapers: [],

            init: async function () {
                // Wait for allData.papers to be ready
                const tableBody = document.getElementById('paper-library-tbody');
                const totalLabel = document.getElementById('library-total-count');

                if (!tableBody) return;

                tableBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding:32px; color:var(--text-secondary);">Loading papers library...</td></tr>';

                // Poll for data readiness
                let attempts = 0;
                while ((!allData || !Array.isArray(allData.papers) || allData.papers.length === 0) && attempts < 40) {
                    await new Promise(r => setTimeout(r, 150));
                    attempts++;
                }

                const rawPapers = (allData && allData.papers) ? allData.papers : [];

                if (rawPapers.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding:32px; color:var(--text-secondary);">No papers available or data failed to load. (allData.papers empty)</td></tr>';
                    if (totalLabel) totalLabel.textContent = '0 papers';
                    return;
                }

                // Set default sorting state
                this.sortKey = 'year';
                this.sortAsc = false;

                // Enable search input
                const searchInput = document.getElementById('library-search');
                if (searchInput) searchInput.disabled = false;

                // Initial Filter (Empty Search)
                this.applyFilters();
            },

            applyFilters: function () {
                const rawPapers = allData.papers || [];

                // 1. Filter logic (Search + Timeframe + Journals)
                const q = (this.searchQuery || '').toLowerCase();
                const startYear = typeof minYear !== 'undefined' ? minYear : 1980;
                const endYear = typeof maxYear !== 'undefined' ? maxYear : 2024;

                this.filteredPapers = rawPapers.filter(p => {
                    const pYear = Number(p.year) || 0;

                    // Time filter
                    if (pYear < startYear || pYear > endYear) return false;

                    // Journal filter
                    if (typeof selectedJournals !== 'undefined' && selectedJournals.size > 0 && p.journal) {
                        if (!selectedJournals.has(p.journal)) return false;
                    }

                    // Search filter
                    if (q) {
                        return (p.title && p.title.toLowerCase().includes(q)) ||
                            (p.authors && p.authors.toLowerCase().includes(q)) ||
                            (p.journal && p.journal.toLowerCase().includes(q));
                    }
                    return true;
                });

                // 2. Stable Sort: Sort by primary key, tie-break by Title ascending
                this.filteredPapers.sort((a, b) => {
                    let valA = a[this.sortKey];
                    let valB = b[this.sortKey];

                    // Handle numeric year
                    if (this.sortKey === 'year') {
                        valA = Number(valA) || 0;
                        valB = Number(valB) || 0;
                    } else {
                        // String safe comparison
                        valA = (valA || '').toString().toLowerCase();
                        valB = (valB || '').toString().toLowerCase();
                    }

                    if (valA < valB) return this.sortAsc ? -1 : 1;
                    if (valA > valB) return this.sortAsc ? 1 : -1;

                    // Tie-breaker: Title (ascending always as stable fallback)
                    let titleA = (a.title || '').toString().toLowerCase();
                    let titleB = (b.title || '').toString().toLowerCase();
                    if (titleA < titleB) return -1;
                    if (titleA > titleB) return 1;

                    return 0;
                });

                // Calculate summary stats for audit
                let minFilteredYear = Infinity;
                let maxFilteredYear = -Infinity;
                this.filteredPapers.forEach(p => {
                    const y = Number(p.year);
                    if (y < minFilteredYear) minFilteredYear = y;
                    if (y > maxFilteredYear) maxFilteredYear = y;
                });
                if (minFilteredYear === Infinity) minFilteredYear = null;
                if (maxFilteredYear === -Infinity) maxFilteredYear = null;

                // Log Audit
                console.group('PAPER LIBRARY FILTER AUDIT');
                console.log(`startYear: ${startYear}, endYear: ${endYear}`);
                console.log(`selectedJournals count: ${typeof selectedJournals !== 'undefined' ? selectedJournals.size : 0}`);
                console.log(`papers before filter: ${rawPapers.length}, papers after filter: ${this.filteredPapers.length}`);
                console.log(`minYear in filtered: ${minFilteredYear}, maxYear in filtered: ${maxFilteredYear}`);
                console.groupEnd();

                // Update total count
                const totalLabel = document.getElementById('library-total-count');
                if (totalLabel) {
                    totalLabel.textContent = `${this.filteredPapers.length} papers`;
                }

                // Make sure pagination restarts to first page when filtering
                this.currentPage = 1;
                this.render();
            },

            sort: function (key) {
                if (this.sortKey === key) {
                    this.sortAsc = !this.sortAsc;
                } else {
                    this.sortKey = key;
                    this.sortAsc = true; // Default asc for new column? Or desc for year? Let's stick to true.
                    // Exception: Year usually better desc by default, but let's keep simple logic.
                    if (key === 'year') this.sortAsc = false; // Year default DESC
                }

                // Update Icons
                ['year', 'title', 'authors', 'journal'].forEach(k => {
                    const icon = document.getElementById(`sort-icon-${k}`);
                    if (icon) {
                        if (k === this.sortKey) {
                            icon.textContent = this.sortAsc ? '▲' : '▼';
                            icon.parentElement.style.color = 'var(--text-primary)';
                        } else {
                            icon.textContent = '';
                            icon.parentElement.style.color = 'var(--text-secondary)';
                        }
                    }
                });

                this.applyFilters();
            },

            changePage: function (delta) {
                const totalPages = Math.ceil(this.filteredPapers.length / this.pageSize) || 1;
                const newPage = this.currentPage + delta;

                if (newPage >= 1 && newPage <= totalPages) {
                    this.currentPage = newPage;
                    this.render();
                }
            },

            render: function () {
                const start = (this.currentPage - 1) * this.pageSize;
                const end = start + this.pageSize;
                const pageData = this.filteredPapers.slice(start, end);

                const tbody = document.getElementById('paper-library-tbody');
                if (!tbody) return;
                tbody.innerHTML = '';

                // Helper to detect missing data reliably
                const isMissing = (value, token) => {
                    if (value === null || value === undefined) return true;
                    if (Array.isArray(value) && value.length === 0) return true;
                    if (typeof value === 'string') {
                        if (value.trim() === '') return true;
                        if (token && value.toLowerCase().includes(token.toLowerCase())) return true;
                    }
                    return false;
                };

                const badgeStyle = "display:inline-block; padding:2px 8px; border-radius:12px; font-size:10px; font-weight:500; background:rgba(255,255,255,0.05); color:var(--text-secondary); border:1px solid rgba(255,255,255,0.1);";

                pageData.forEach(p => {
                    const tr = document.createElement('tr');
                    tr.style.borderBottom = '1px solid var(--chart-row-border)';
                    tr.style.transition = 'background 0.1s';
                    tr.onmouseover = () => tr.style.background = 'var(--chart-row-hover)';
                    tr.onmouseout = () => tr.style.background = 'transparent';

                    let isMissingAuthor = isMissing(p.authors, 'missing_author');
                    let isMissingJournal = isMissing(p.journal);

                    let displayAuthors = Array.isArray(p.authors) ? p.authors.join(', ') : p.authors;

                    let authorsHTML = isMissingAuthor
                        ? `<span style="${badgeStyle}">Missing authors</span>`
                        : displayAuthors;

                    let journalHTML = isMissingJournal
                        ? `<span style="${badgeStyle}">Missing journal</span>`
                        : p.journal;

                    let titleHTML = isMissing(p.title) ? 'Untitled paper' : p.title;

                    // Ensure safe escaping for tooltips
                    let safeAuthorsAttr = !isMissingAuthor && typeof displayAuthors === 'string'
                        ? displayAuthors.replace(/"/g, '&quot;')
                        : '';

                    tr.innerHTML = `
                        <td style="padding:8px 12px; color:var(--text-secondary); font-family:monospace; font-size:12px; vertical-align:top;">${p.year || ''}</td>
                        <td style="padding:8px 12px; color:var(--text-primary); font-weight:600; font-size:13px; line-height:1.4; white-space:normal; overflow-wrap:anywhere; vertical-align:top;">${titleHTML}</td>
                        <td style="padding:8px 12px; color:var(--text-secondary); font-size:12px; line-height:1.4; vertical-align:top;" ${!isMissingAuthor ? `title="${safeAuthorsAttr}"` : ''}>${authorsHTML}</td>
                        <td style="padding:8px 12px; color:var(--text-secondary); font-style:italic; font-size:12px; line-height:1.4; vertical-align:top;">${journalHTML}</td>
                    `;
                    tbody.appendChild(tr);
                });

                // Update Controls
                const totalCount = this.filteredPapers.length;
                const totalPages = Math.ceil(totalCount / this.pageSize) || 1;

                const info = document.getElementById('lib-page-info');
                const prev = document.getElementById('lib-prev-btn');
                const next = document.getElementById('lib-next-btn');
                const totalLabel = document.getElementById('library-total-count');

                if (info) info.textContent = `Page ${this.currentPage} of ${totalPages}`;
                if (prev) prev.disabled = (this.currentPage <= 1);
                if (next) next.disabled = (this.currentPage >= totalPages);
                if (totalLabel) totalLabel.textContent = `${totalCount} papers`;

                // Log Audit
                console.groupCollapsed('PAPER LIBRARY PAGINATION AUDIT');
                console.log(`filteredTotal: ${totalCount}`);
                console.log(`pageSize: ${this.pageSize}`);
                console.log(`currentPage: ${this.currentPage}`);
                console.log(`totalPages: ${totalPages}`);
                if (pageData.length > 0) {
                    console.log(`firstRowYear: ${pageData[0].year}`);
                    console.log(`firstRowTitle: ${pageData[0].title}`);
                }
                console.groupEnd();
            }
        };



        // Start the application after all definitions are ready
        loadData().then(() => {
            if (typeof populateAdvancedFilters === 'function') {
                populateAdvancedFilters();
            }
        }).catch(e => {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.style.display = 'flex';
                loading.innerHTML = `<div style="color:red; text-align:center; padding:50px;">Error loading data: ${e.message}</div>`;
            }
        });
    </script>

</body>

</html>